# ğŸš€ Deploy RaspaGanha V2 - Health Check Profissional (Big Companies Style)

name: Deploy RaspaGanha V2 Professional

on:
  push:
    branches: [main, master]
  workflow_dispatch:

jobs:
  # Job 1: Deploy para produÃ§Ã£o
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v4
        
      - name: ğŸš€ Deploy to Vercel (PRODUÃ‡ÃƒO)
        uses: amondnet/vercel-action@v25
        id: vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_TEAM_ID }}
          vercel-project-id: rasparei
          vercel-args: '--prod'
          
      - name: â³ Aguardar Deploy de ProduÃ§Ã£o
        run: |
          echo "â³ Aguardando deploy de PRODUÃ‡ÃƒO ficar disponÃ­vel..."
          echo "ğŸŒ Deploy serÃ¡ promovido automaticamente para https://rasparei.com/"
          sleep 45
          
      - name: ğŸ“± Notificar Deploy de ProduÃ§Ã£o
        run: |
          MESSAGE="ğŸš€ Deploy PRODUÃ‡ÃƒO iniciado%0A%0AğŸŒ Site: https://rasparei.com/%0AğŸ“Š Commit: ${GITHUB_SHA:0:7}%0AğŸ‘¤ Por: ${{ github.actor }}%0AğŸ”„ Aguardando health check..."
          
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$MESSAGE"

  # Job 2: Health Check Profissional (igual Ã s Big Companies)
  health-check:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    outputs:
      health_passed: ${{ steps.health.outputs.health_passed }}
      status_code: ${{ steps.health.outputs.status_code }}
      response_time: ${{ steps.health.outputs.response_time }}
      errors_count: ${{ steps.health.outputs.errors_count }}
      error_details: ${{ steps.health.outputs.error_details }}
    
    steps:
      - name: ğŸ” Health Check Profissional
        id: health
        run: |
          echo "ğŸ” Health Check - Estilo Big Companies"
          echo "======================================"
          
          ERRORS=0
          
          # 1. AVAILABILITY CHECK - O mais importante
          echo "ğŸ“Š 1. Testando disponibilidade..."
          
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total}" --max-time 10 "https://rasparei.com/" || echo "HTTPSTATUS:000;TIME:999")
          STATUS=$(echo $RESPONSE | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
          TIME=$(echo $RESPONSE | grep -o "TIME:[0-9.]*" | cut -d: -f2)
          
          echo "   Status: $STATUS"
          echo "   Tempo: ${TIME}s"
          
          # 2. CRITICAL ERRORS ONLY - SÃ³ erros que realmente importam
          if [[ "$STATUS" != "200" ]]; then
            echo "âŒ FALHA CRÃTICA: Site nÃ£o responde (HTTP $STATUS)"
            ERRORS=$((ERRORS + 1))
          elif (( $(echo "$TIME > 5.0" | bc -l 2>/dev/null || echo "0") )); then
            echo "âŒ FALHA CRÃTICA: Site muito lento (${TIME}s > 5s)"
            ERRORS=$((ERRORS + 1))
          else
            echo "âœ… Site disponÃ­vel e responsivo"
          fi
          
          # 3. BASIC CONTENT CHECK - SÃ³ verificar se nÃ£o Ã© pÃ¡gina de erro
          echo "ğŸ“„ 2. Verificando conteÃºdo bÃ¡sico..."
          
          CONTENT=$(curl -s --max-time 10 "https://rasparei.com/" || echo "")
          CONTENT_SIZE=${#CONTENT}
          
          echo "   Tamanho: $CONTENT_SIZE chars"
          
          if [[ $CONTENT_SIZE -lt 1000 ]]; then
            echo "âŒ FALHA CRÃTICA: ConteÃºdo muito pequeno - possÃ­vel erro"
            ERRORS=$((ERRORS + 1))
          elif echo "$CONTENT" | grep -qi "500\|internal server error\|application error\|fatal error\|error occurred\|something went wrong\|bailout_to_client_side_rendering"; then
            echo "âŒ FALHA CRÃTICA: PÃ¡gina de erro detectada"
            
            # Mostrar qual erro foi detectado para debug
            if echo "$CONTENT" | grep -qi "bailout_to_client_side_rendering"; then
              echo "   ğŸ” Erro especÃ­fico: BAILOUT_TO_CLIENT_SIDE_RENDERING (Next.js hydration)"
            elif echo "$CONTENT" | grep -qi "500"; then
              echo "   ğŸ” Erro especÃ­fico: HTTP 500 (Internal Server Error)"
            elif echo "$CONTENT" | grep -qi "application error"; then
              echo "   ğŸ” Erro especÃ­fico: Application Error"
            else
              echo "   ğŸ” Erro especÃ­fico: Erro genÃ©rico detectado no conteÃºdo"
            fi
            
            ERRORS=$((ERRORS + 1))
          else
            echo "âœ… ConteÃºdo carregado normalmente"
          fi
          
          # 4. FINAL RESULT - SÃ³ falha se realmente crÃ­tico
          echo ""
          echo "ğŸ“Š RESULTADO FINAL:"
          echo "âŒ Falhas crÃ­ticas: $ERRORS"
          
          # Coletar detalhes do erro
          ERROR_DETAILS=""
          if [[ "$ERRORS" -gt 0 ]]; then
            if [[ "$STATUS" != "200" ]]; then
              ERROR_DETAILS="Site nÃ£o responde (HTTP $STATUS)"
            elif (( $(echo "$TIME > 5.0" | bc -l 2>/dev/null || echo "0") )); then
              ERROR_DETAILS="Site muito lento (${TIME}s)"
            elif echo "$CONTENT" | grep -qi "bailout_to_client_side_rendering"; then
              ERROR_DETAILS="Erro de hidrataÃ§Ã£o Next.js"
            elif echo "$CONTENT" | grep -qi "500"; then
              ERROR_DETAILS="Erro interno do servidor"
            elif echo "$CONTENT" | grep -qi "application error"; then
              ERROR_DETAILS="Erro da aplicaÃ§Ã£o"
            else
              ERROR_DETAILS="ConteÃºdo muito pequeno ou erro genÃ©rico"
            fi
          fi
          
          # Salvar informaÃ§Ãµes
          echo "errors_count=$ERRORS" >> $GITHUB_OUTPUT
          echo "status_code=$STATUS" >> $GITHUB_OUTPUT
          echo "response_time=$TIME" >> $GITHUB_OUTPUT
          echo "error_details=$ERROR_DETAILS" >> $GITHUB_OUTPUT
          
          if [[ "$ERRORS" -gt 0 ]]; then
            echo ""
            echo "ğŸš¨ HEALTH CHECK FALHOU - PROBLEMA CRÃTICO DETECTADO"
            echo "health_passed=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo ""
            echo "âœ… HEALTH CHECK PASSOU - SITE FUNCIONANDO"
            echo "health_passed=true" >> $GITHUB_OUTPUT
          fi

  # Job 3: Rollback AutomÃ¡tico
  rollback:
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: always() && needs.health-check.result == 'failure'
    outputs:
      rollback_executed: ${{ steps.rollback.outputs.executed }}
    
    steps:
      - name: ğŸ” Debug Rollback
        run: |
          echo "ğŸ” DEBUG ROLLBACK:"
          echo "Health check result: ${{ needs.health-check.result }}"
          echo "Health check passed: ${{ needs.health-check.outputs.health_passed }}"
          echo "Event name: ${{ github.event_name }}"
          
      - name: ğŸ”„ Rollback AutomÃ¡tico
        id: rollback
        run: |
          echo "ğŸš¨ EXECUTANDO ROLLBACK AUTOMÃTICO..."
          echo "Deploy automÃ¡tico falhou - revertendo"
          
          npm install -g vercel@latest
          
          echo "ğŸ” Buscando deployment anterior..."
          echo "ğŸ“‹ Listando Ãºltimos 10 deployments..."
          DEPLOYMENTS=$(npx vercel ls rasparei --token="${{ secrets.VERCEL_TOKEN }}" --scope="${{ secrets.VERCEL_SCOPE }}" -m 10)
          echo "$DEPLOYMENTS"
          
          # Buscar APENAS deployments Ready para rollback
          echo "ğŸ” Procurando deployments Ready para rollback..."
          READY_DEPLOYMENTS=$(echo "$DEPLOYMENTS" | grep "â— Ready" | grep "Production" || true)
          echo "ğŸ“‹ Deployments Ready encontrados:"
          echo "$READY_DEPLOYMENTS"
          
          # Contar quantos deployments Ready temos
          READY_COUNT=$(echo "$READY_DEPLOYMENTS" | grep -c "https://" || echo "0")
          echo "ğŸ“Š Total de deployments Ready: $READY_COUNT"
          
          if [ "$READY_COUNT" -ge 2 ]; then
            # Pegar o segundo deployment Ready (o primeiro Ã© o atual que falhou)
            PREVIOUS_URL=$(echo "$READY_DEPLOYMENTS" | sed -n '2p' | awk '{print $1}')
            echo "ğŸ”„ Executando rollback para o deployment anterior: $PREVIOUS_URL"
          elif [ "$READY_COUNT" -eq 1 ]; then
            # Se sÃ³ tem 1, usar ele mesmo (melhor que nada)
            PREVIOUS_URL=$(echo "$READY_DEPLOYMENTS" | head -1 | awk '{print $1}')
            echo "ğŸ”„ SÃ³ hÃ¡ 1 deployment Ready, usando ele: $PREVIOUS_URL"
          else
            echo "âŒ Nenhum deployment Ready encontrado"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Executar o rollback
          if [ -n "$PREVIOUS_URL" ]; then
            npx vercel promote "$PREVIOUS_URL" --token="${{ secrets.VERCEL_TOKEN }}" --scope="${{ secrets.VERCEL_SCOPE }}" --yes
            
            if [ $? -eq 0 ]; then
              echo "âœ… ROLLBACK EXECUTADO!"
              echo "ğŸ§ª Aguardando 30s para estabilizar..."
              sleep 30
              
              # Verificar se funcionou
              ROLLBACK_STATUS=$(curl -s -w "%{http_code}" -o /dev/null --max-time 30 "https://rasparei.com/" || echo "000")
              
              if [[ "$ROLLBACK_STATUS" == "200" ]]; then
                echo "âœ… ROLLBACK VERIFICADO - SITE FUNCIONANDO!"
                echo "executed=true" >> $GITHUB_OUTPUT
              else
                echo "âŒ ROLLBACK FALHOU (Status: $ROLLBACK_STATUS)"
                echo "executed=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "âŒ Comando de rollback falhou"
              echo "executed=false" >> $GITHUB_OUTPUT
            fi
          fi

  # Job 4: NotificaÃ§Ãµes
  notify:
    runs-on: ubuntu-latest
    needs: [health-check, rollback]
    if: always()
    
    steps:
      - name: ğŸ“± Telegram Notification
        run: |
          HEALTH_PASSED="${{ needs.health-check.outputs.health_passed }}"
          STATUS_CODE="${{ needs.health-check.outputs.status_code }}"
          RESPONSE_TIME="${{ needs.health-check.outputs.response_time }}"
          ERRORS="${{ needs.health-check.outputs.errors_count }}"
          ERROR_DETAILS="${{ needs.health-check.outputs.error_details }}"
          ROLLBACK="${{ needs.rollback.outputs.rollback_executed || 'nÃ£o executado' }}"
          ROLLBACK_JOB_STATUS="${{ needs.rollback.result || 'nÃ£o executado' }}"
          
          if [[ "$HEALTH_PASSED" == "true" ]]; then
            # Sucesso
            MESSAGE="âœ… RaspaGanha V2 - FUNCIONANDO!%0A%0AğŸŒ Site: https://rasparei.com/%0AğŸ“Š Status: $STATUS_CODE%0Aâš¡ Tempo: ${RESPONSE_TIME}s%0AğŸ“Š Commit: ${GITHUB_SHA:0:7}%0A%0AğŸ¯ Deploy estilo Big Companies!"
          else
            # Falha
            if [[ "$ROLLBACK" == "true" ]]; then
              MESSAGE="ğŸ”„ ROLLBACK EXECUTADO!%0A%0AğŸš¨ Deploy falhou ($ERRORS erros crÃ­ticos)%0Aâœ… Site revertido automaticamente%0AğŸŒ https://rasparei.com/%0AğŸ“Š Status: $STATUS_CODE%0AğŸ“Š Commit: ${GITHUB_SHA:0:7}%0A%0Aâœ… USUÃRIOS PROTEGIDOS!"
            else
              MESSAGE="ğŸš¨ DEPLOY FALHOU!%0A%0AâŒ Falhas crÃ­ticas: $ERRORS%0AğŸ” Erro: $ERROR_DETAILS%0AğŸ“Š Status: $STATUS_CODE%0Aâš¡ Tempo: ${RESPONSE_TIME}s%0AğŸ”„ Rollback: $ROLLBACK_JOB_STATUS%0AğŸŒ https://rasparei.com/%0AğŸ“Š Commit: ${GITHUB_SHA:0:7}%0A%0AğŸ”¥ INTERVENÃ‡ÃƒO NECESSÃRIA!"
            fi
          fi
          
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$MESSAGE"

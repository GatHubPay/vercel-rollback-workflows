# üöÄ Deploy RaspaGanha V2 - Health Check Profissional (Big Companies Style)

name: Deploy RaspaGanha V2 Professional

on:
  push:
    branches: [main, master]
  workflow_dispatch:

jobs:
  # Job 1: Deploy para produ√ß√£o
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4
        
      - name: üöÄ Deploy to Vercel (PRODU√á√ÉO)
        uses: amondnet/vercel-action@v25
        id: vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_TEAM_ID }}
          vercel-project-id: rasparei
          vercel-args: '--prod'
          
      - name: ‚è≥ Aguardar Deploy de Produ√ß√£o
        run: |
          echo "‚è≥ Aguardando deploy de PRODU√á√ÉO ficar dispon√≠vel..."
          echo "üåê Deploy ser√° promovido automaticamente para https://rasparei.com/"
          sleep 45
          
      - name: üì± Notificar Deploy de Produ√ß√£o
        run: |
          MESSAGE="üöÄ Deploy PRODU√á√ÉO iniciado%0A%0Aüåê Site: https://rasparei.com/%0Aüìä Commit: ${GITHUB_SHA:0:7}%0Aüë§ Por: ${{ github.actor }}%0AüîÑ Aguardando health check..."
          
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$MESSAGE"

  # Job 2: Health Check Profissional (igual √†s Big Companies)
  health-check:
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    outputs:
      health_passed: ${{ steps.health.outputs.health_passed }}
      status_code: ${{ steps.health.outputs.status_code }}
      response_time: ${{ steps.health.outputs.response_time }}
      errors_count: ${{ steps.health.outputs.errors_count }}
      error_details: ${{ steps.health.outputs.error_details }}
    
    steps:
      - name: üîç Health Check Profissional
        id: health
        run: |
          echo "üîç Health Check - Estilo Big Companies"
          echo "======================================"
          
          ERRORS=0
          
          # 1. AVAILABILITY CHECK - O mais importante
          echo "üìä 1. Testando disponibilidade..."
          
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total}" --max-time 10 "https://rasparei.com/" || echo "HTTPSTATUS:000;TIME:999")
          STATUS=$(echo $RESPONSE | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
          TIME=$(echo $RESPONSE | grep -o "TIME:[0-9.]*" | cut -d: -f2)
          
          echo "   Status: $STATUS"
          echo "   Tempo: ${TIME}s"
          
          # 2. CRITICAL ERRORS ONLY - S√≥ erros que realmente importam
          if [[ "$STATUS" != "200" ]]; then
            echo "‚ùå FALHA CR√çTICA: Site n√£o responde (HTTP $STATUS)"
            ERRORS=$((ERRORS + 1))
          elif (( $(echo "$TIME > 5.0" | bc -l 2>/dev/null || echo "0") )); then
            echo "‚ùå FALHA CR√çTICA: Site muito lento (${TIME}s > 5s)"
            ERRORS=$((ERRORS + 1))
          else
            echo "‚úÖ Site dispon√≠vel e responsivo"
          fi
          
          # 3. BASIC CONTENT CHECK - S√≥ verificar se n√£o √© p√°gina de erro
          echo "üìÑ 2. Verificando conte√∫do b√°sico..."
          
          CONTENT=$(curl -s --max-time 10 "https://rasparei.com/" || echo "")
          CONTENT_SIZE=${#CONTENT}
          
          echo "   Tamanho: $CONTENT_SIZE chars"
          
          if [[ $CONTENT_SIZE -lt 1000 ]]; then
            echo "‚ùå FALHA CR√çTICA: Conte√∫do muito pequeno - poss√≠vel erro"
            ERRORS=$((ERRORS + 1))
          elif echo "$CONTENT" | grep -qi "500\|internal server error\|application error\|fatal error\|error occurred\|something went wrong\|bailout_to_client_side_rendering"; then
            echo "‚ùå FALHA CR√çTICA: P√°gina de erro detectada"
            
            # Mostrar qual erro foi detectado para debug
            if echo "$CONTENT" | grep -qi "bailout_to_client_side_rendering"; then
              echo "   üîç Erro espec√≠fico: BAILOUT_TO_CLIENT_SIDE_RENDERING (Next.js hydration)"
            elif echo "$CONTENT" | grep -qi "500"; then
              echo "   üîç Erro espec√≠fico: HTTP 500 (Internal Server Error)"
            elif echo "$CONTENT" | grep -qi "application error"; then
              echo "   üîç Erro espec√≠fico: Application Error"
            else
              echo "   üîç Erro espec√≠fico: Erro gen√©rico detectado no conte√∫do"
            fi
            
            ERRORS=$((ERRORS + 1))
          else
            echo "‚úÖ Conte√∫do carregado normalmente"
          fi
          
          # 4. FINAL RESULT - S√≥ falha se realmente cr√≠tico
          echo ""
          echo "üìä RESULTADO FINAL:"
          echo "‚ùå Falhas cr√≠ticas: $ERRORS"
          
          # Coletar detalhes do erro
          ERROR_DETAILS=""
          if [[ "$ERRORS" -gt 0 ]]; then
            if [[ "$STATUS" != "200" ]]; then
              ERROR_DETAILS="Site n√£o responde (HTTP $STATUS)"
            elif (( $(echo "$TIME > 5.0" | bc -l 2>/dev/null || echo "0") )); then
              ERROR_DETAILS="Site muito lento (${TIME}s)"
            elif echo "$CONTENT" | grep -qi "bailout_to_client_side_rendering"; then
              ERROR_DETAILS="Erro de hidrata√ß√£o Next.js"
            elif echo "$CONTENT" | grep -qi "500"; then
              ERROR_DETAILS="Erro interno do servidor"
            elif echo "$CONTENT" | grep -qi "application error"; then
              ERROR_DETAILS="Erro da aplica√ß√£o"
            else
              ERROR_DETAILS="Conte√∫do muito pequeno ou erro gen√©rico"
            fi
          fi
          
          # Salvar informa√ß√µes
          echo "errors_count=$ERRORS" >> $GITHUB_OUTPUT
          echo "status_code=$STATUS" >> $GITHUB_OUTPUT
          echo "response_time=$TIME" >> $GITHUB_OUTPUT
          echo "error_details=$ERROR_DETAILS" >> $GITHUB_OUTPUT
          
          if [[ "$ERRORS" -gt 0 ]]; then
            echo ""
            echo "üö® HEALTH CHECK FALHOU - PROBLEMA CR√çTICO DETECTADO"
            echo "health_passed=false" >> $GITHUB_OUTPUT
            exit 1
          else
            echo ""
            echo "‚úÖ HEALTH CHECK PASSOU - SITE FUNCIONANDO"
            echo "health_passed=true" >> $GITHUB_OUTPUT
          fi

  # Job 3: Rollback Autom√°tico
  rollback:
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: always() && needs.health-check.result == 'failure'
    outputs:
      rollback_executed: ${{ steps.rollback.outputs.executed }}
    
    steps:
      - name: üîç Debug Rollback
        run: |
          echo "üîç DEBUG ROLLBACK:"
          echo "Health check result: ${{ needs.health-check.result }}"
          echo "Health check passed: ${{ needs.health-check.outputs.health_passed }}"
          echo "Event name: ${{ github.event_name }}"
          
      - name: üîÑ Rollback Autom√°tico
        id: rollback
        run: |
          echo "üö® EXECUTANDO ROLLBACK AUTOM√ÅTICO..."
          echo "Deploy autom√°tico falhou - revertendo"
          
          npm install -g vercel@latest
          
          # üß† ROLLBACK INTELIGENTE - Identifica qual deployment √© o atual vs anterior
          echo "üîç INICIANDO ROLLBACK INTELIGENTE..."
          
          # 1. Pegar o deployment que ACABOU de ser criado (o quebrado)
          echo "üìã 1. Identificando deployment atual (quebrado)..."
          CURRENT_DEPLOYMENT_URL="${{ steps.vercel-deploy.outputs.preview-url }}"
          echo "üö® Deployment atual (QUEBRADO): $CURRENT_DEPLOYMENT_URL"
          
          # 2. Listar todos deployments para encontrar o anterior
          echo "üìã 2. Listando todos os deployments..."
          ALL_DEPLOYMENTS=$(npx vercel ls rasparei --token="${{ secrets.VERCEL_TOKEN }}" --scope="${{ secrets.VERCEL_SCOPE }}" -m 20)
          echo "$ALL_DEPLOYMENTS"
          
          # 3. Filtrar apenas deployments Ready de Production (excluindo o atual quebrado)
          echo "üîç 3. Filtrando deployments Ready (excluindo o quebrado)..."
          READY_DEPLOYMENTS=$(echo "$ALL_DEPLOYMENTS" | grep "‚óè Ready" | grep "Production" || true)
          
          # 4. Remover o deployment atual da lista (o quebrado)
          SAFE_DEPLOYMENTS=""
          while IFS= read -r line; do
            if [[ -n "$line" ]]; then
              DEPLOYMENT_URL=$(echo "$line" | awk '{print $1}')
              if [[ "$DEPLOYMENT_URL" != "$CURRENT_DEPLOYMENT_URL" ]]; then
                SAFE_DEPLOYMENTS="$SAFE_DEPLOYMENTS$line"$'\n'
              else
                echo "üö´ Pulando deployment quebrado: $DEPLOYMENT_URL"
              fi
            fi
          done <<< "$READY_DEPLOYMENTS"
          
          echo "‚úÖ Deployments SEGUROS dispon√≠veis:"
          echo "$SAFE_DEPLOYMENTS"
          
          # 5. Pegar o primeiro deployment seguro (mais recente que n√£o √© o quebrado)
          ROLLBACK_URL=$(echo "$SAFE_DEPLOYMENTS" | head -1 | awk '{print $1}')
          
          if [[ -n "$ROLLBACK_URL" && "$ROLLBACK_URL" != "" ]]; then
            echo "üéØ ROLLBACK TARGET IDENTIFICADO: $ROLLBACK_URL"
            echo "üîÑ Executando rollback para deployment seguro..."
            
            npx vercel promote "$ROLLBACK_URL" --token="${{ secrets.VERCEL_TOKEN }}" --scope="${{ secrets.VERCEL_SCOPE }}" --yes
          else
            echo "‚ùå ERRO CR√çTICO: Nenhum deployment seguro encontrado!"
            echo "üîç Poss√≠veis causas:"
            echo "   ‚Ä¢ Todos deployments Ready s√£o o atual (quebrado)"
            echo "   ‚Ä¢ N√£o h√° deployments anteriores Ready"
            echo "   ‚Ä¢ Problema na filtragem dos deployments"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ $? -eq 0 ]; then
              echo "‚úÖ ROLLBACK EXECUTADO!"
              echo "üß™ Aguardando 30s para estabilizar..."
              sleep 30
              
              # Verificar se funcionou
              ROLLBACK_STATUS=$(curl -s -w "%{http_code}" -o /dev/null --max-time 30 "https://rasparei.com/" || echo "000")
              
              if [[ "$ROLLBACK_STATUS" == "200" ]]; then
                echo "‚úÖ ROLLBACK VERIFICADO - SITE FUNCIONANDO!"
                echo "executed=true" >> $GITHUB_OUTPUT
              else
                echo "‚ùå ROLLBACK FALHOU (Status: $ROLLBACK_STATUS)"
                echo "executed=false" >> $GITHUB_OUTPUT
              fi
            else
              echo "‚ùå Comando de rollback falhou"
              echo "executed=false" >> $GITHUB_OUTPUT
            fi
          fi

  # Job 4: Notifica√ß√µes
  notify:
    runs-on: ubuntu-latest
    needs: [health-check, rollback]
    if: always()
    
    steps:
      - name: üì± Telegram Notification
        run: |
          HEALTH_PASSED="${{ needs.health-check.outputs.health_passed }}"
          STATUS_CODE="${{ needs.health-check.outputs.status_code }}"
          RESPONSE_TIME="${{ needs.health-check.outputs.response_time }}"
          ERRORS="${{ needs.health-check.outputs.errors_count }}"
          ERROR_DETAILS="${{ needs.health-check.outputs.error_details }}"
          ROLLBACK="${{ needs.rollback.outputs.rollback_executed || 'n√£o executado' }}"
          ROLLBACK_JOB_STATUS="${{ needs.rollback.result || 'n√£o executado' }}"
          
          if [[ "$HEALTH_PASSED" == "true" ]]; then
            # Sucesso
            MESSAGE="‚úÖ RaspaGanha V2 - FUNCIONANDO!%0A%0Aüåê Site: https://rasparei.com/%0Aüìä Status: $STATUS_CODE%0A‚ö° Tempo: ${RESPONSE_TIME}s%0Aüìä Commit: ${GITHUB_SHA:0:7}%0A%0AüéØ Deploy estilo Big Companies!"
          else
            # Falha
            if [[ "$ROLLBACK" == "true" ]]; then
              MESSAGE="üîÑ ROLLBACK EXECUTADO!%0A%0Aüö® Deploy falhou ($ERRORS erros cr√≠ticos)%0A‚úÖ Site revertido automaticamente%0Aüåê https://rasparei.com/%0Aüìä Status: $STATUS_CODE%0Aüìä Commit: ${GITHUB_SHA:0:7}%0A%0A‚úÖ USU√ÅRIOS PROTEGIDOS!"
            else
              MESSAGE="üö® DEPLOY FALHOU!%0A%0A‚ùå Falhas cr√≠ticas: $ERRORS%0Aüîç Erro: $ERROR_DETAILS%0Aüìä Status: $STATUS_CODE%0A‚ö° Tempo: ${RESPONSE_TIME}s%0AüîÑ Rollback: $ROLLBACK_JOB_STATUS%0Aüåê https://rasparei.com/%0Aüìä Commit: ${GITHUB_SHA:0:7}%0A%0Aüî• INTERVEN√á√ÉO NECESS√ÅRIA!"
            fi
          fi
          
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$MESSAGE"

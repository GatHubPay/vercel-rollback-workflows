name: Reusable Vercel Deploy + Auto Rollback

on:
  workflow_call:
    inputs:
      vercelProject:
        description: "Nome exato do projeto no Vercel"
        required: true
        type: string
      routes:
        description: "Rotas para health check, separadas por v√≠rgula (ex: '/,/login,/checkout'). Deixe vazio para auto-detec√ß√£o"
        required: false
        type: string
        default: ""
      healthCheckTimeout:
        description: "Timeout em segundos para cada health check (padr√£o: 30)"
        required: false
        type: number
        default: 30
      maxRetries:
        description: "M√°ximo de tentativas para health check (padr√£o: 3)"
        required: false
        type: number
        default: 3
      enablePostDeployMonitoring:
        description: "Habilitar monitoramento p√≥s-deploy (padr√£o: true)"
        required: false
        type: boolean
        default: true
      monitoringDurationMinutes:
        description: "Dura√ß√£o do monitoramento p√≥s-deploy em minutos (padr√£o: 30)"
        required: false
        type: number
        default: 30
      monitoringIntervalMinutes:
        description: "Intervalo entre verifica√ß√µes em minutos (padr√£o: 5)"
        required: false
        type: number
        default: 5
    secrets:
      VERCEL_TOKEN:
        required: true
      TELEGRAM_BOT_TOKEN:
        required: true
      TELEGRAM_CHAT_ID:
        required: true
    outputs:
      deployUrl:
        description: "URL do deployment realizado"
        value: ${{ jobs.deploy-and-guard.outputs.deploy_url }}
      rollbackExecuted:
        description: "Se rollback foi executado"
        value: ${{ jobs.deploy-and-guard.outputs.rollback_executed }}

jobs:
  deploy-and-guard:
    runs-on: ubuntu-latest
    outputs:
      deploy_url: ${{ steps.discover.outputs.deploy_url }}
      rollback_executed: ${{ steps.rollback.outputs.executed || 'false' }}
    steps:
      - name: Checkout (repo que chamou)
        uses: actions/checkout@v4

      - name: Instalar ferramentas
        run: |
          npm install -g vercel@latest
          sudo apt-get update
          sudo apt-get install -y jq curl bc
          
      - name: Validar inputs
        run: |
          if [ -z "${{ inputs.vercelProject }}" ]; then
            echo "‚ùå Nome do projeto Vercel √© obrigat√≥rio"
            exit 1
          fi
          echo "‚úÖ Projeto: ${{ inputs.vercelProject }}"
          echo "‚úÖ Rotas configuradas: ${{ inputs.routes }}"
          echo "‚úÖ Timeout: ${{ inputs.healthCheckTimeout }}s"
          echo "‚úÖ Max retries: ${{ inputs.maxRetries }}"

      - name: Deploy para Vercel (produ√ß√£o)
        id: deploy
        run: |
          echo "üöÄ Iniciando deploy para produ√ß√£o..."
          
          # Deploy com captura de output
          DEPLOY_OUTPUT=$(npx vercel --prod --confirm \
            --token="${{ secrets.VERCEL_TOKEN }}" 2>&1)
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Falha no deploy:"
            echo "$DEPLOY_OUTPUT"
            exit 1
          fi
          
          echo "‚úÖ Deploy realizado com sucesso"
          echo "$DEPLOY_OUTPUT"

      - name: Descobrir URL do √∫ltimo deploy em produ√ß√£o
        id: discover
        run: |
          echo "üîç Buscando informa√ß√µes do projeto..."
          
          # Pega o ID do projeto
          PROJECT_INFO=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v9/projects/${{ inputs.vercelProject }}")
          
          HTTP_STATUS=$(echo "$PROJECT_INFO" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          PROJECT_DATA=$(echo "$PROJECT_INFO" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro ao buscar projeto (HTTP $HTTP_STATUS):"
            echo "$PROJECT_DATA"
            exit 1
          fi
          
          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.id')
          if [ "$PROJECT_ID" = "null" ] || [ -z "$PROJECT_ID" ]; then
            echo "‚ùå Projeto '${{ inputs.vercelProject }}' n√£o encontrado"
            exit 1
          fi
          
          echo "‚úÖ Projeto encontrado: $PROJECT_ID"
          
          # Aguarda alguns segundos para o deploy ficar dispon√≠vel
          echo "‚è≥ Aguardando deploy ficar dispon√≠vel..."
          sleep 15
          
          # Pega o deployment mais recente pronto em produ√ß√£o
          LATEST=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v6/deployments?projectId=$PROJECT_ID&limit=1&state=READY&target=production")
          
          HTTP_STATUS=$(echo "$LATEST" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          DEPLOY_DATA=$(echo "$LATEST" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro ao buscar deployments (HTTP $HTTP_STATUS)"
            exit 1
          fi
          
          DEPLOY_URL=$(echo "$DEPLOY_DATA" | jq -r '.deployments[0].url')
          if [ "$DEPLOY_URL" = "null" ] || [ -z "$DEPLOY_URL" ]; then
            echo "‚ùå Nenhum deployment encontrado"
            exit 1
          fi
          
          FULL_URL="https://$DEPLOY_URL"
          echo "‚úÖ URL do deploy: $FULL_URL"
          echo "deploy_url=$FULL_URL" >> $GITHUB_OUTPUT

      - name: Detec√ß√£o inteligente de rotas
        id: route_detection
        run: |
          CONFIGURED_ROUTES="${{ inputs.routes }}"
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          
          if [ -n "$CONFIGURED_ROUTES" ]; then
            echo "‚úÖ Usando rotas configuradas: $CONFIGURED_ROUTES"
            echo "routes=$CONFIGURED_ROUTES" >> $GITHUB_OUTPUT
          else
            echo "üîç Iniciando detec√ß√£o autom√°tica de rotas..."
            
            # Rotas padr√£o sempre testadas
            AUTO_ROUTES="/"
            
            # Tenta detectar rotas comuns
            echo "üïµÔ∏è Verificando rotas comuns..."
            
            # Lista de rotas para testar
            COMMON_ROUTES="/api/health /health /api/status /login /dashboard /produtos /posts /sobre /contato /carrinho /checkout"
            
            for route in $COMMON_ROUTES; do
              echo "  Testando: $route"
              if curl -s --connect-timeout 5 --max-time 10 -f "$DEPLOY_URL$route" > /dev/null 2>&1; then
                echo "  ‚úÖ Encontrada: $route"
                AUTO_ROUTES="$AUTO_ROUTES,$route"
              else
                echo "  ‚ùå N√£o encontrada: $route"
              fi
            done
            
            # Tenta detectar APIs Next.js
            echo "üîç Verificando estrutura Next.js..."
            if curl -s --connect-timeout 5 --max-time 10 -f "$DEPLOY_URL/_next/static" > /dev/null 2>&1; then
              echo "‚úÖ Aplica√ß√£o Next.js detectada"
              AUTO_ROUTES="$AUTO_ROUTES,/_next/static"
            fi
            
            echo "‚úÖ Rotas detectadas automaticamente: $AUTO_ROUTES"
            echo "routes=$AUTO_ROUTES" >> $GITHUB_OUTPUT
          fi

      - name: Health checks nas rotas
        id: health
        run: |
          set +e
          FAIL=0
          ROUTES="${{ steps.route_detection.outputs.routes }}"
          TIMEOUT="${{ inputs.healthCheckTimeout }}"
          MAX_RETRIES="${{ inputs.maxRetries }}"
          
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          echo "üè• Iniciando health checks..."
          echo "üìç URL base: $DEPLOY_URL"
          echo "üõ£Ô∏è  Rotas: $ROUTES"
          echo "‚è±Ô∏è  Timeout: ${TIMEOUT}s por requisi√ß√£o"
          echo "üîÑ Max retries: $MAX_RETRIES"
          
          # Fun√ß√£o para testar uma URL com retry
          test_url() {
            local url="$1"
            local attempt=1
            
            while [ $attempt -le $MAX_RETRIES ]; do
              echo "   Tentativa $attempt/$MAX_RETRIES para $url"
              
              # Testa conectividade b√°sica primeiro
              if ! curl -s --connect-timeout 5 --max-time $TIMEOUT -f "$url" > /dev/null 2>&1; then
                echo "   ‚ùå Falha na conectividade (tentativa $attempt)"
                if [ $attempt -eq $MAX_RETRIES ]; then
                  return 1
                fi
                sleep $((attempt * 2)) # Backoff exponencial
                attempt=$((attempt + 1))
                continue
              fi
              
              # Pega o status code
              CODE=$(curl -s --connect-timeout 5 --max-time $TIMEOUT -o /dev/null -w "%{http_code}" "$url")
              
              # Considera sucesso 200-399
              if [ "$CODE" -ge 200 ] && [ "$CODE" -lt 400 ]; then
                echo "   ‚úÖ $url -> $CODE (OK)"
                return 0
              else
                echo "   ‚ùå $url -> $CODE (ERRO)"
                if [ $attempt -eq $MAX_RETRIES ]; then
                  return 1
                fi
                sleep $((attempt * 2))
                attempt=$((attempt + 1))
              fi
            done
            
            return 1
          }
          
          # Testa cada rota
          IFS=',' read -ra ARR <<< "$ROUTES"
          for path in "${ARR[@]}"; do
            # Remove espa√ßos em branco
            path=$(echo "$path" | xargs)
            
            # Garante que a rota come√ßa com /
            if [[ "$path" != /* ]]; then path="/$path"; fi
            
            url="${DEPLOY_URL}${path}"
            echo "üß™ Testando rota: $path"
            
            if ! test_url "$url"; then
              echo "‚ùå Falha no health check para $path"
              FAIL=1
            fi
          done
          
          # Resultado final
          if [ $FAIL -eq 1 ]; then
            echo "‚ùå Health check FALHOU"
            echo "failed=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Health check PASSOU"
            echo "failed=false" >> $GITHUB_OUTPUT
          fi

      - name: Enviar notifica√ß√£o de sucesso
        if: steps.health.outputs.failed == 'false'
        run: |
          # Credenciais do Telegram (configuradas)
          BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
          CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}"
          
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          PROJECT_NAME="${{ inputs.vercelProject }}"
          
          MESSAGE="‚úÖ *Deploy Bem-Sucedido!*%0A%0A*Projeto:* $PROJECT_NAME%0A*Status:* SUCESSO%0A*Rollback:* N√ÉO EXECUTADO%0A*URL:* $DEPLOY_URL%0A*Repo:* ${{ github.repository }}%0A*Commit:* ${{ github.sha }}%0A*Data:* $(date)"
          
          echo "üì® Enviando notifica√ß√£o de sucesso para Telegram..."
          
          curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
            -d "chat_id=$CHAT_ID" \
            -d "text=$MESSAGE" \
            -d "parse_mode=Markdown" || echo "‚ö†Ô∏è Falha ao enviar notifica√ß√£o"

      - name: Instant Rollback (se falhar)
        id: rollback
        if: steps.health.outputs.failed == 'true'
        run: |
          echo "üö® Health check FALHOU - Iniciando rollback autom√°tico..."
          
          # Busca informa√ß√µes do projeto
          PROJECT_INFO=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v9/projects/${{ inputs.vercelProject }}")
          
          HTTP_STATUS=$(echo "$PROJECT_INFO" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          PROJECT_DATA=$(echo "$PROJECT_INFO" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro ao buscar projeto para rollback (HTTP $HTTP_STATUS)"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.id')
          
          # Busca hist√≥rico de deployments
          echo "üîç Buscando deployment anterior para rollback..."
          HIST=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v6/deployments?projectId=$PROJECT_ID&limit=5&state=READY&target=production")
          
          HTTP_STATUS=$(echo "$HIST" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          HIST_DATA=$(echo "$HIST" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro ao buscar hist√≥rico de deployments"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Pega o deployment anterior (√≠ndice 1, pois 0 √© o atual que falhou)
          PREV_UID=$(echo "$HIST_DATA" | jq -r '.deployments[1].uid')
          PREV_URL=$(echo "$HIST_DATA" | jq -r '.deployments[1].url')
          PREV_CREATED=$(echo "$HIST_DATA" | jq -r '.deployments[1].createdAt')
          
          if [ "$PREV_UID" = "null" ] || [ -z "$PREV_UID" ]; then
            echo "‚ùå N√£o h√° deployment anterior v√°lido para rollback"
            echo "Deployments dispon√≠veis:"
            echo "$HIST_DATA" | jq -r '.deployments[] | "- \(.uid) (\(.createdAt))"'
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ Deployment anterior encontrado:"
          echo "   UID: $PREV_UID"
          echo "   URL: https://$PREV_URL"
          echo "   Criado: $PREV_CREATED"
          
          # Executa o rollback
          echo "üîÑ Executando rollback..."
          ROLLBACK_RESULT=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -X POST "https://api.vercel.com/v9/projects/$PROJECT_ID/rollback/$PREV_UID" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            -H "Content-Type: application/json")
          
          HTTP_STATUS=$(echo "$ROLLBACK_RESULT" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          ROLLBACK_DATA=$(echo "$ROLLBACK_RESULT" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro ao executar rollback (HTTP $HTTP_STATUS):"
            echo "$ROLLBACK_DATA"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ Rollback executado com sucesso!"
          echo "executed=true" >> $GITHUB_OUTPUT
          
          # Aguarda um pouco para o rollback ser aplicado
          echo "‚è≥ Aguardando rollback ser aplicado..."
          sleep 20
          
          # Testa se o rollback funcionou
          echo "üß™ Verificando se rollback foi bem-sucedido..."
          ROLLBACK_URL="https://$PREV_URL"
          
          if curl -s --connect-timeout 10 --max-time 30 -f "$ROLLBACK_URL" > /dev/null 2>&1; then
            echo "‚úÖ Rollback verificado - aplica√ß√£o est√° respondendo"
          else
            echo "‚ö†Ô∏è Aviso: N√£o foi poss√≠vel verificar o rollback imediatamente"
          fi

      - name: Enviar notifica√ß√£o de rollback
        if: steps.rollback.outputs.executed == 'true'
        run: |
          # Credenciais do Telegram (configuradas)
          BOT_TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
          CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}"
          
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          PROJECT_NAME="${{ inputs.vercelProject }}"
          
          MESSAGE="üö® *Rollback Executado!*%0A%0A*Projeto:* $PROJECT_NAME%0A*Status:* FALHOU%0A*Rollback:* EXECUTADO COM SUCESSO%0A*URL Original:* $DEPLOY_URL%0A*Repo:* ${{ github.repository }}%0A*Commit:* ${{ github.sha }}%0A*Motivo:* Health check falhou%0A*Data:* $(date)%0A%0AA aplica√ß√£o foi automaticamente revertida para a vers√£o anterior est√°vel."
          
          echo "üì® Enviando notifica√ß√£o de rollback para Telegram..."
          
          curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
            -d "chat_id=$CHAT_ID" \
            -d "text=$MESSAGE" \
            -d "parse_mode=Markdown" || echo "‚ö†Ô∏è Falha ao enviar notifica√ß√£o"

      - name: Resumo final
        if: always()
        run: |
          echo "üìä RESUMO DO DEPLOY"
          echo "===================="
          echo "üèóÔ∏è Projeto: ${{ inputs.vercelProject }}"
          echo "üåê URL: ${{ steps.discover.outputs.deploy_url }}"
          echo "üè• Health Check: ${{ steps.health.outputs.failed == 'true' && '‚ùå FALHOU' || '‚úÖ PASSOU' }}"
          echo "üîÑ Rollback: ${{ steps.rollback.outputs.executed == 'true' && '‚úÖ EXECUTADO' || '‚ùå N√ÉO EXECUTADO' }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üîó Reposit√≥rio: ${{ github.repository }}"
          echo "===================="
          
          if [ "${{ steps.health.outputs.failed }}" = "true" ]; then
            echo "‚ö†Ô∏è ATEN√á√ÉO: Deploy falhou e rollback foi executado!"
            echo "   Verifique os logs acima para detalhes do erro."
            exit 1
          else
            echo "üéâ Deploy realizado com sucesso!"
          fi

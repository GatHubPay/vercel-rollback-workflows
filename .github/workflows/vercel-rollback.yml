name: Reusable Vercel Deploy + Auto Rollback

on:
  workflow_call:
    inputs:
      vercelProject:
        description: "Nome exato do projeto no Vercel"
        required: true
        type: string
      routes:
        description: "Rotas para health check, separadas por vÃ­rgula (ex: '/,/login,/checkout'). Deixe vazio para auto-detecÃ§Ã£o"
        required: false
        type: string
        default: ""
      healthCheckTimeout:
        description: "Timeout em segundos para cada health check (padrÃ£o: 30)"
        required: false
        type: number
        default: 30
      maxRetries:
        description: "MÃ¡ximo de tentativas para health check (padrÃ£o: 3)"
        required: false
        type: number
        default: 3
      enablePostDeployMonitoring:
        description: "Habilitar monitoramento pÃ³s-deploy (padrÃ£o: true)"
        required: false
        type: boolean
        default: true
      monitoringDurationMinutes:
        description: "DuraÃ§Ã£o do monitoramento pÃ³s-deploy em minutos (padrÃ£o: 30)"
        required: false
        type: number
        default: 30
      monitoringIntervalMinutes:
        description: "Intervalo entre verificaÃ§Ãµes em minutos (padrÃ£o: 5)"
        required: false
        type: number
        default: 5
    secrets:
      VERCEL_TOKEN:
        required: true
      VERCEL_TEAM_ID:
        required: true
      VERCEL_SCOPE:
        required: true
    outputs:
      deployUrl:
        description: "URL do deployment realizado"
        value: ${{ jobs.deploy-and-guard.outputs.deploy_url }}
      rollbackExecuted:
        description: "Se rollback foi executado"
        value: ${{ jobs.deploy-and-guard.outputs.rollback_executed }}

jobs:
  deploy-and-guard:
    runs-on: ubuntu-latest
    outputs:
      deploy_url: ${{ steps.discover.outputs.deploy_url }}
      rollback_executed: ${{ steps.rollback.outputs.executed || 'false' }}
    steps:
      - name: Checkout (repo que chamou)
        uses: actions/checkout@v4

      - name: Instalar ferramentas
        run: |
          npm install -g vercel@latest
          sudo apt-get update
          sudo apt-get install -y jq curl bc
          
      - name: Validar inputs
        run: |
          if [ -z "${{ inputs.vercelProject }}" ]; then
            echo "âŒ Nome do projeto Vercel Ã© obrigatÃ³rio"
            exit 1
          fi
          echo "âœ… Projeto: ${{ inputs.vercelProject }}"
          echo "âœ… Rotas configuradas: ${{ inputs.routes }}"
          echo "âœ… Timeout: ${{ inputs.healthCheckTimeout }}s"
          echo "âœ… Max retries: ${{ inputs.maxRetries }}"

      - name: Deploy para Vercel (produÃ§Ã£o)
        id: deploy
        run: |
          echo "ğŸš€ Iniciando deploy para produÃ§Ã£o..."
          
          # Deploy com captura de output
          DEPLOY_OUTPUT=$(npx vercel --prod --confirm \
            --token="${{ secrets.VERCEL_TOKEN }}" \
            --scope="${{ secrets.VERCEL_SCOPE }}" 2>&1)
          
          if [ $? -ne 0 ]; then
            echo "âŒ Falha no deploy:"
            echo "$DEPLOY_OUTPUT"
            exit 1
          fi
          
          echo "âœ… Deploy realizado com sucesso"
          echo "$DEPLOY_OUTPUT"

      - name: Descobrir URL do Ãºltimo deploy em produÃ§Ã£o
        id: discover
        run: |
          echo "ğŸ” Buscando informaÃ§Ãµes do projeto..."
          
          # Pega o ID do projeto
          PROJECT_INFO=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v9/projects/${{ inputs.vercelProject }}?teamId=${{ secrets.VERCEL_TEAM_ID }}")
          
          HTTP_STATUS=$(echo "$PROJECT_INFO" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          PROJECT_DATA=$(echo "$PROJECT_INFO" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "âŒ Erro ao buscar projeto (HTTP $HTTP_STATUS):"
            echo "$PROJECT_DATA"
            exit 1
          fi
          
          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.id')
          if [ "$PROJECT_ID" = "null" ] || [ -z "$PROJECT_ID" ]; then
            echo "âŒ Projeto '${{ inputs.vercelProject }}' nÃ£o encontrado"
            exit 1
          fi
          
          echo "âœ… Projeto encontrado: $PROJECT_ID"
          
          # Aguarda alguns segundos para o deploy ficar disponÃ­vel
          echo "â³ Aguardando deploy ficar disponÃ­vel..."
          sleep 15
          
          # Pega o deployment mais recente pronto em produÃ§Ã£o
          LATEST=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v6/deployments?projectId=$PROJECT_ID&teamId=${{ secrets.VERCEL_TEAM_ID }}&target=production&limit=1&state=READY")
          
          HTTP_STATUS=$(echo "$LATEST" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          DEPLOY_DATA=$(echo "$LATEST" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "âŒ Erro ao buscar deployments (HTTP $HTTP_STATUS)"
            exit 1
          fi
          
          DEPLOY_URL=$(echo "$DEPLOY_DATA" | jq -r '.deployments[0].url')
          if [ "$DEPLOY_URL" = "null" ] || [ -z "$DEPLOY_URL" ]; then
            echo "âŒ Nenhum deployment encontrado"
            exit 1
          fi
          
          FULL_URL="https://$DEPLOY_URL"
          echo "âœ… URL do deploy: $FULL_URL"
          echo "deploy_url=$FULL_URL" >> $GITHUB_OUTPUT

      - name: DetecÃ§Ã£o inteligente de rotas
        id: route_detection
        run: |
          CONFIGURED_ROUTES="${{ inputs.routes }}"
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          
          if [ -n "$CONFIGURED_ROUTES" ]; then
            echo "âœ… Usando rotas configuradas: $CONFIGURED_ROUTES"
            echo "routes=$CONFIGURED_ROUTES" >> $GITHUB_OUTPUT
          else
            echo "ğŸ” Iniciando detecÃ§Ã£o automÃ¡tica de rotas..."
            
            # Rotas padrÃ£o sempre testadas
            AUTO_ROUTES="/"
            
            # Tenta detectar rotas comuns
            echo "ğŸ•µï¸ Verificando rotas comuns..."
            
            # Lista de rotas para testar
            COMMON_ROUTES="/api/health /health /api/status /login /dashboard /produtos /posts /sobre /contato /carrinho /checkout"
            
            for route in $COMMON_ROUTES; do
              echo "  Testando: $route"
              if curl -s --connect-timeout 5 --max-time 10 -f "$DEPLOY_URL$route" > /dev/null 2>&1; then
                echo "  âœ… Encontrada: $route"
                AUTO_ROUTES="$AUTO_ROUTES,$route"
              else
                echo "  âŒ NÃ£o encontrada: $route"
              fi
            done
            
            # Tenta detectar APIs Next.js
            echo "ğŸ” Verificando estrutura Next.js..."
            if curl -s --connect-timeout 5 --max-time 10 -f "$DEPLOY_URL/_next/static" > /dev/null 2>&1; then
              echo "âœ… AplicaÃ§Ã£o Next.js detectada"
              AUTO_ROUTES="$AUTO_ROUTES,/_next/static"
            fi
            
            echo "âœ… Rotas detectadas automaticamente: $AUTO_ROUTES"
            echo "routes=$AUTO_ROUTES" >> $GITHUB_OUTPUT
          fi

      - name: Health checks nas rotas
        id: health
        run: |
          set +e
          FAIL=0
          ROUTES="${{ steps.route_detection.outputs.routes }}"
          TIMEOUT="${{ inputs.healthCheckTimeout }}"
          MAX_RETRIES="${{ inputs.maxRetries }}"
          
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          echo "ğŸ¥ Iniciando health checks..."
          echo "ğŸ“ URL base: $DEPLOY_URL"
          echo "ğŸ›£ï¸  Rotas: $ROUTES"
          echo "â±ï¸  Timeout: ${TIMEOUT}s por requisiÃ§Ã£o"
          echo "ğŸ”„ Max retries: $MAX_RETRIES"
          
          # FunÃ§Ã£o para testar uma URL com retry
          test_url() {
            local url="$1"
            local attempt=1
            
            while [ $attempt -le $MAX_RETRIES ]; do
              echo "   Tentativa $attempt/$MAX_RETRIES para $url"
              
              # Testa conectividade bÃ¡sica primeiro
              if ! curl -s --connect-timeout 5 --max-time $TIMEOUT -f "$url" > /dev/null 2>&1; then
                echo "   âŒ Falha na conectividade (tentativa $attempt)"
                if [ $attempt -eq $MAX_RETRIES ]; then
                  return 1
                fi
                sleep $((attempt * 2)) # Backoff exponencial
                attempt=$((attempt + 1))
                continue
              fi
              
              # Pega o status code
              CODE=$(curl -s --connect-timeout 5 --max-time $TIMEOUT -o /dev/null -w "%{http_code}" "$url")
              
              # Considera sucesso 200-399
              if [ "$CODE" -ge 200 ] && [ "$CODE" -lt 400 ]; then
                echo "   âœ… $url -> $CODE (OK)"
                return 0
              else
                echo "   âŒ $url -> $CODE (ERRO)"
                if [ $attempt -eq $MAX_RETRIES ]; then
                  return 1
                fi
                sleep $((attempt * 2))
                attempt=$((attempt + 1))
              fi
            done
            
            return 1
          }
          
          # Testa cada rota
          IFS=',' read -ra ARR <<< "$ROUTES"
          for path in "${ARR[@]}"; do
            # Remove espaÃ§os em branco
            path=$(echo "$path" | xargs)
            
            # Garante que a rota comeÃ§a com /
            if [[ "$path" != /* ]]; then path="/$path"; fi
            
            url="${DEPLOY_URL}${path}"
            echo "ğŸ§ª Testando rota: $path"
            
            if ! test_url "$url"; then
              echo "âŒ Falha no health check para $path"
              FAIL=1
            fi
          done
          
          # Resultado final
          if [ $FAIL -eq 1 ]; then
            echo "âŒ Health check FALHOU"
            echo "failed=true" >> $GITHUB_OUTPUT
          else
            echo "âœ… Health check PASSOU"
            echo "failed=false" >> $GITHUB_OUTPUT
          fi

      - name: Enviar notificaÃ§Ã£o de sucesso
        if: steps.health.outputs.failed == 'false'
        run: |
          # Credenciais do Telegram (configuradas)
          BOT_TOKEN="8045408592:AAHtPkn2DTPTrL3rs5lLFbV4vhPDEMAqodw"
          CHAT_ID="5649252463"
          
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          PROJECT_NAME="${{ inputs.vercelProject }}"
          
          MESSAGE="âœ… *Deploy Bem-Sucedido!*

ğŸ—ï¸ *Projeto:* $PROJECT_NAME
ğŸ“Š *Status:* SUCESSO
ğŸ”„ *Rollback:* NÃƒO EXECUTADO
ğŸŒ *URL:* $DEPLOY_URL
ğŸ“ *Repo:* ${{ github.repository }}
ğŸ“ *Commit:* ${{ github.sha }}
â° *Data:* $(date)"
          
          echo "ğŸ“¨ Enviando notificaÃ§Ã£o de sucesso para Telegram..."
          
          curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
            -d "chat_id=$CHAT_ID" \
            -d "text=$MESSAGE" \
            -d "parse_mode=Markdown" || echo "âš ï¸ Falha ao enviar notificaÃ§Ã£o"

      - name: Instant Rollback (se falhar)
        id: rollback
        if: steps.health.outputs.failed == 'true'
        run: |
          echo "ğŸš¨ Health check FALHOU - Iniciando rollback automÃ¡tico..."
          
          # Busca informaÃ§Ãµes do projeto
          PROJECT_INFO=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v9/projects/${{ inputs.vercelProject }}?teamId=${{ secrets.VERCEL_TEAM_ID }}")
          
          HTTP_STATUS=$(echo "$PROJECT_INFO" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          PROJECT_DATA=$(echo "$PROJECT_INFO" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "âŒ Erro ao buscar projeto para rollback (HTTP $HTTP_STATUS)"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.id')
          
          # Busca histÃ³rico de deployments
          echo "ğŸ” Buscando deployment anterior para rollback..."
          HIST=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v6/deployments?teamId=${{ secrets.VERCEL_TEAM_ID }}&projectId=$PROJECT_ID&limit=5&state=READY&target=production")
          
          HTTP_STATUS=$(echo "$HIST" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          HIST_DATA=$(echo "$HIST" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "âŒ Erro ao buscar histÃ³rico de deployments"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Pega o deployment anterior (Ã­ndice 1, pois 0 Ã© o atual que falhou)
          PREV_UID=$(echo "$HIST_DATA" | jq -r '.deployments[1].uid')
          PREV_URL=$(echo "$HIST_DATA" | jq -r '.deployments[1].url')
          PREV_CREATED=$(echo "$HIST_DATA" | jq -r '.deployments[1].createdAt')
          
          if [ "$PREV_UID" = "null" ] || [ -z "$PREV_UID" ]; then
            echo "âŒ NÃ£o hÃ¡ deployment anterior vÃ¡lido para rollback"
            echo "Deployments disponÃ­veis:"
            echo "$HIST_DATA" | jq -r '.deployments[] | "- \(.uid) (\(.createdAt))"'
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "âœ… Deployment anterior encontrado:"
          echo "   UID: $PREV_UID"
          echo "   URL: https://$PREV_URL"
          echo "   Criado: $PREV_CREATED"
          
          # Executa o rollback
          echo "ğŸ”„ Executando rollback..."
          ROLLBACK_RESULT=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -X POST "https://api.vercel.com/v9/projects/$PROJECT_ID/rollback/$PREV_UID?teamId=${{ secrets.VERCEL_TEAM_ID }}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            -H "Content-Type: application/json")
          
          HTTP_STATUS=$(echo "$ROLLBACK_RESULT" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          ROLLBACK_DATA=$(echo "$ROLLBACK_RESULT" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "âŒ Erro ao executar rollback (HTTP $HTTP_STATUS):"
            echo "$ROLLBACK_DATA"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "âœ… Rollback executado com sucesso!"
          echo "executed=true" >> $GITHUB_OUTPUT
          
          # Aguarda um pouco para o rollback ser aplicado
          echo "â³ Aguardando rollback ser aplicado..."
          sleep 20
          
          # Testa se o rollback funcionou
          echo "ğŸ§ª Verificando se rollback foi bem-sucedido..."
          ROLLBACK_URL="https://$PREV_URL"
          
          if curl -s --connect-timeout 10 --max-time 30 -f "$ROLLBACK_URL" > /dev/null 2>&1; then
            echo "âœ… Rollback verificado - aplicaÃ§Ã£o estÃ¡ respondendo"
          else
            echo "âš ï¸ Aviso: NÃ£o foi possÃ­vel verificar o rollback imediatamente"
          fi

      - name: Enviar notificaÃ§Ã£o de rollback
        if: steps.rollback.outputs.executed == 'true'
        run: |
          # Credenciais do Telegram (configuradas)
          BOT_TOKEN="8045408592:AAHtPkn2DTPTrL3rs5lLFbV4vhPDEMAqodw"
          CHAT_ID="5649252463"
          
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          PROJECT_NAME="${{ inputs.vercelProject }}"
          
          MESSAGE="ğŸš¨ *Rollback Executado!*

ğŸ—ï¸ *Projeto:* $PROJECT_NAME
ğŸ“Š *Status:* FALHOU
ğŸ”„ *Rollback:* EXECUTADO COM SUCESSO
ğŸŒ *URL Original:* $DEPLOY_URL
ğŸ“ *Repo:* ${{ github.repository }}
ğŸ“ *Commit:* ${{ github.sha }}
âš ï¸ *Motivo:* Health check falhou
â° *Data:* $(date)

A aplicaÃ§Ã£o foi automaticamente revertida para a versÃ£o anterior estÃ¡vel."
          
          echo "ğŸ“¨ Enviando notificaÃ§Ã£o de rollback para Telegram..."
          
          curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
            -d "chat_id=$CHAT_ID" \
            -d "text=$MESSAGE" \
            -d "parse_mode=Markdown" || echo "âš ï¸ Falha ao enviar notificaÃ§Ã£o"

      - name: Resumo final
        if: always()
        run: |
          echo "ğŸ“Š RESUMO DO DEPLOY"
          echo "===================="
          echo "ğŸ—ï¸ Projeto: ${{ inputs.vercelProject }}"
          echo "ğŸŒ URL: ${{ steps.discover.outputs.deploy_url }}"
          echo "ğŸ¥ Health Check: ${{ steps.health.outputs.failed == 'true' && 'âŒ FALHOU' || 'âœ… PASSOU' }}"
          echo "ğŸ”„ Rollback: ${{ steps.rollback.outputs.executed == 'true' && 'âœ… EXECUTADO' || 'âŒ NÃƒO EXECUTADO' }}"
          echo "ğŸ“ Commit: ${{ github.sha }}"
          echo "ğŸ”— RepositÃ³rio: ${{ github.repository }}"
          echo "===================="
          
          if [ "${{ steps.health.outputs.failed }}" = "true" ]; then
            echo "âš ï¸ ATENÃ‡ÃƒO: Deploy falhou e rollback foi executado!"
            echo "   Verifique os logs acima para detalhes do erro."
            exit 1
          else
            echo "ğŸ‰ Deploy realizado com sucesso!"
          fi

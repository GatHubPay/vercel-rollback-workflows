name: Reusable Vercel Deploy + Auto Rollback

on:
  workflow_call:
    inputs:
      vercelProject:
        description: "Nome exato do projeto no Vercel"
        required: true
        type: string
      routes:
        description: "Rotas para health check, separadas por v√≠rgula (ex: '/,/login,/checkout'). Deixe vazio para auto-detec√ß√£o"
        required: false
        type: string
        default: ""
      healthCheckTimeout:
        description: "Timeout em segundos para cada health check (padr√£o: 30)"
        required: false
        type: number
        default: 30
      maxRetries:
        description: "M√°ximo de tentativas para health check (padr√£o: 3)"
        required: false
        type: number
        default: 3
      enablePostDeployMonitoring:
        description: "Habilitar monitoramento p√≥s-deploy (padr√£o: true)"
        required: false
        type: boolean
        default: true
      monitoringDurationMinutes:
        description: "Dura√ß√£o do monitoramento p√≥s-deploy em minutos (padr√£o: 30)"
        required: false
        type: number
        default: 30
      monitoringIntervalMinutes:
        description: "Intervalo entre verifica√ß√µes em minutos (padr√£o: 5)"
        required: false
        type: number
        default: 5
    secrets:
      VERCEL_TOKEN:
        required: true
      VERCEL_TEAM_ID:
        required: true
      VERCEL_SCOPE:
        required: true
    outputs:
      deployUrl:
        description: "URL do deployment realizado"
        value: ${{ jobs.deploy-and-guard.outputs.deploy_url }}
      rollbackExecuted:
        description: "Se rollback foi executado"
        value: ${{ jobs.deploy-and-guard.outputs.rollback_executed }}

jobs:
  deploy-and-guard:
    runs-on: ubuntu-latest
    outputs:
      deploy_url: ${{ steps.discover.outputs.deploy_url }}
      rollback_executed: ${{ steps.rollback.outputs.executed || 'false' }}
    steps:
      - name: Checkout (repo que chamou)
        uses: actions/checkout@v4

      - name: Instalar ferramentas
        run: |
          npm install -g vercel@latest
          sudo apt-get update
          sudo apt-get install -y jq curl bc
          
      - name: Validar inputs
        run: |
          if [ -z "${{ inputs.vercelProject }}" ]; then
            echo "‚ùå Nome do projeto Vercel √© obrigat√≥rio"
            exit 1
          fi
          echo "‚úÖ Projeto: ${{ inputs.vercelProject }}"
          echo "‚úÖ Rotas configuradas: ${{ inputs.routes }}"
          echo "‚úÖ Timeout: ${{ inputs.healthCheckTimeout }}s"
          echo "‚úÖ Max retries: ${{ inputs.maxRetries }}"

      - name: Deploy para Vercel (produ√ß√£o)
        id: deploy
        run: |
          echo "üöÄ Iniciando deploy para produ√ß√£o..."
          
          # Deploy com captura de output
          DEPLOY_OUTPUT=$(npx vercel --prod --confirm \
            --token="${{ secrets.VERCEL_TOKEN }}" \
            --scope="${{ secrets.VERCEL_SCOPE }}" 2>&1)
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Falha no deploy:"
            echo "$DEPLOY_OUTPUT"
            exit 1
          fi
          
          echo "‚úÖ Deploy realizado com sucesso"
          echo "$DEPLOY_OUTPUT"

      - name: Descobrir URL do √∫ltimo deploy em produ√ß√£o
        id: discover
        run: |
          echo "üîç Buscando informa√ß√µes do projeto..."
          
          # Pega o ID do projeto
          PROJECT_INFO=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v9/projects/${{ inputs.vercelProject }}?teamId=${{ secrets.VERCEL_TEAM_ID }}")
          
          HTTP_STATUS=$(echo "$PROJECT_INFO" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          PROJECT_DATA=$(echo "$PROJECT_INFO" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro ao buscar projeto (HTTP $HTTP_STATUS):"
            echo "$PROJECT_DATA"
            exit 1
          fi
          
          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.id')
          if [ "$PROJECT_ID" = "null" ] || [ -z "$PROJECT_ID" ]; then
            echo "‚ùå Projeto '${{ inputs.vercelProject }}' n√£o encontrado"
            exit 1
          fi
          
          echo "‚úÖ Projeto encontrado: $PROJECT_ID"
          
          # Aguarda alguns segundos para o deploy ficar dispon√≠vel
          echo "‚è≥ Aguardando deploy ficar dispon√≠vel..."
          sleep 15
          
          # Pega o deployment mais recente pronto em produ√ß√£o
          LATEST=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v6/deployments?projectId=$PROJECT_ID&teamId=${{ secrets.VERCEL_TEAM_ID }}&target=production&limit=1&state=READY")
          
          HTTP_STATUS=$(echo "$LATEST" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          DEPLOY_DATA=$(echo "$LATEST" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro ao buscar deployments (HTTP $HTTP_STATUS)"
            exit 1
          fi
          
          DEPLOY_URL=$(echo "$DEPLOY_DATA" | jq -r '.deployments[0].url')
          if [ "$DEPLOY_URL" = "null" ] || [ -z "$DEPLOY_URL" ]; then
            echo "‚ùå Nenhum deployment encontrado"
            exit 1
          fi
          
          FULL_URL="https://$DEPLOY_URL"
          echo "‚úÖ URL do deploy: $FULL_URL"
          echo "deploy_url=$FULL_URL" >> $GITHUB_OUTPUT

      - name: Detec√ß√£o inteligente de rotas
        id: route_detection
        run: |
          CONFIGURED_ROUTES="${{ inputs.routes }}"
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          
          if [ -n "$CONFIGURED_ROUTES" ]; then
            echo "‚úÖ Usando rotas configuradas: $CONFIGURED_ROUTES"
            echo "routes=$CONFIGURED_ROUTES" >> $GITHUB_OUTPUT
          else
            echo "üîç Iniciando detec√ß√£o autom√°tica de rotas..."
            
            # Rotas padr√£o sempre testadas
            AUTO_ROUTES="/"
            
            # Tenta detectar rotas comuns
            echo "üïµÔ∏è Verificando rotas comuns..."
            
            # Lista de rotas para testar
            COMMON_ROUTES="/api/health /health /api/status /login /dashboard /produtos /posts /sobre /contato /carrinho /checkout"
            
            for route in $COMMON_ROUTES; do
              echo "  Testando: $route"
              if curl -s --connect-timeout 5 --max-time 10 -f "$DEPLOY_URL$route" > /dev/null 2>&1; then
                echo "  ‚úÖ Encontrada: $route"
                AUTO_ROUTES="$AUTO_ROUTES,$route"
              else
                echo "  ‚ùå N√£o encontrada: $route"
              fi
            done
            
            # Tenta detectar APIs Next.js
            echo "üîç Verificando estrutura Next.js..."
            if curl -s --connect-timeout 5 --max-time 10 -f "$DEPLOY_URL/_next/static" > /dev/null 2>&1; then
              echo "‚úÖ Aplica√ß√£o Next.js detectada"
              AUTO_ROUTES="$AUTO_ROUTES,/_next/static"
            fi
            
            echo "‚úÖ Rotas detectadas automaticamente: $AUTO_ROUTES"
            echo "routes=$AUTO_ROUTES" >> $GITHUB_OUTPUT
          fi

      - name: Health checks nas rotas
        id: health
        run: |
          set +e
          FAIL=0
          ROUTES="${{ steps.route_detection.outputs.routes }}"
          TIMEOUT="${{ inputs.healthCheckTimeout }}"
          MAX_RETRIES="${{ inputs.maxRetries }}"
          
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          echo "üè• Iniciando health checks..."
          echo "üìç URL base: $DEPLOY_URL"
          echo "üõ£Ô∏è  Rotas: $ROUTES"
          echo "‚è±Ô∏è  Timeout: ${TIMEOUT}s por requisi√ß√£o"
          echo "üîÑ Max retries: $MAX_RETRIES"
          
          # Fun√ß√£o para testar uma URL com retry
          test_url() {
            local url="$1"
            local attempt=1
            
            while [ $attempt -le $MAX_RETRIES ]; do
              echo "   Tentativa $attempt/$MAX_RETRIES para $url"
              
              # Testa conectividade b√°sica primeiro
              if ! curl -s --connect-timeout 5 --max-time $TIMEOUT -f "$url" > /dev/null 2>&1; then
                echo "   ‚ùå Falha na conectividade (tentativa $attempt)"
                if [ $attempt -eq $MAX_RETRIES ]; then
                  return 1
                fi
                sleep $((attempt * 2)) # Backoff exponencial
                attempt=$((attempt + 1))
                continue
              fi
              
              # Pega o status code
              CODE=$(curl -s --connect-timeout 5 --max-time $TIMEOUT -o /dev/null -w "%{http_code}" "$url")
              
              # Considera sucesso 200-399
              if [ "$CODE" -ge 200 ] && [ "$CODE" -lt 400 ]; then
                echo "   ‚úÖ $url -> $CODE (OK)"
                return 0
              else
                echo "   ‚ùå $url -> $CODE (ERRO)"
                if [ $attempt -eq $MAX_RETRIES ]; then
                  return 1
                fi
                sleep $((attempt * 2))
                attempt=$((attempt + 1))
              fi
            done
            
            return 1
          }
          
          # Testa cada rota
          IFS=',' read -ra ARR <<< "$ROUTES"
          for path in "${ARR[@]}"; do
            # Remove espa√ßos em branco
            path=$(echo "$path" | xargs)
            
            # Garante que a rota come√ßa com /
            if [[ "$path" != /* ]]; then path="/$path"; fi
            
            url="${DEPLOY_URL}${path}"
            echo "üß™ Testando rota: $path"
            
            if ! test_url "$url"; then
              echo "‚ùå Falha no health check para $path"
              FAIL=1
            fi
          done
          
          # Resultado final
          if [ $FAIL -eq 1 ]; then
            echo "‚ùå Health check FALHOU"
            echo "failed=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Health check PASSOU"
            echo "failed=false" >> $GITHUB_OUTPUT
          fi

      - name: Enviar notifica√ß√£o de sucesso
        if: steps.health.outputs.failed == 'false'
        run: |
          # Credenciais do Telegram (configuradas)
          BOT_TOKEN="8045408592:AAHtPkn2DTPTrL3rs5lLFbV4vhPDEMAqodw"
          CHAT_ID="5649252463"
          
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          PROJECT_NAME="${{ inputs.vercelProject }}"
          
          MESSAGE="‚úÖ *Deploy Bem-Sucedido!*

üèóÔ∏è *Projeto:* $PROJECT_NAME
üìä *Status:* SUCESSO
üîÑ *Rollback:* N√ÉO EXECUTADO
üåê *URL:* $DEPLOY_URL
üìÅ *Repo:* ${{ github.repository }}
üìù *Commit:* ${{ github.sha }}
‚è∞ *Data:* $(date)"
          
          echo "üì® Enviando notifica√ß√£o de sucesso para Telegram..."
          
          curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
            -d "chat_id=$CHAT_ID" \
            -d "text=$MESSAGE" \
            -d "parse_mode=Markdown" || echo "‚ö†Ô∏è Falha ao enviar notifica√ß√£o"

      - name: Instant Rollback (se falhar)
        id: rollback
        if: steps.health.outputs.failed == 'true'
        run: |
          echo "üö® Health check FALHOU - Iniciando rollback autom√°tico..."
          
          # Busca informa√ß√µes do projeto
          PROJECT_INFO=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v9/projects/${{ inputs.vercelProject }}?teamId=${{ secrets.VERCEL_TEAM_ID }}")
          
          HTTP_STATUS=$(echo "$PROJECT_INFO" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          PROJECT_DATA=$(echo "$PROJECT_INFO" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro ao buscar projeto para rollback (HTTP $HTTP_STATUS)"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          PROJECT_ID=$(echo "$PROJECT_DATA" | jq -r '.id')
          
          # Busca hist√≥rico de deployments
          echo "üîç Buscando deployment anterior para rollback..."
          HIST=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            "https://api.vercel.com/v6/deployments?teamId=${{ secrets.VERCEL_TEAM_ID }}&projectId=$PROJECT_ID&limit=5&state=READY&target=production")
          
          HTTP_STATUS=$(echo "$HIST" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          HIST_DATA=$(echo "$HIST" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro ao buscar hist√≥rico de deployments"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Pega o deployment anterior (√≠ndice 1, pois 0 √© o atual que falhou)
          PREV_UID=$(echo "$HIST_DATA" | jq -r '.deployments[1].uid')
          PREV_URL=$(echo "$HIST_DATA" | jq -r '.deployments[1].url')
          PREV_CREATED=$(echo "$HIST_DATA" | jq -r '.deployments[1].createdAt')
          
          if [ "$PREV_UID" = "null" ] || [ -z "$PREV_UID" ]; then
            echo "‚ùå N√£o h√° deployment anterior v√°lido para rollback"
            echo "Deployments dispon√≠veis:"
            echo "$HIST_DATA" | jq -r '.deployments[] | "- \(.uid) (\(.createdAt))"'
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ Deployment anterior encontrado:"
          echo "   UID: $PREV_UID"
          echo "   URL: https://$PREV_URL"
          echo "   Criado: $PREV_CREATED"
          
          # Executa o rollback
          echo "üîÑ Executando rollback..."
          ROLLBACK_RESULT=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -X POST "https://api.vercel.com/v9/projects/$PROJECT_ID/rollback/$PREV_UID?teamId=${{ secrets.VERCEL_TEAM_ID }}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            -H "Content-Type: application/json")
          
          HTTP_STATUS=$(echo "$ROLLBACK_RESULT" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
          ROLLBACK_DATA=$(echo "$ROLLBACK_RESULT" | sed 's/HTTP_STATUS:[0-9]*$//')
          
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "‚ùå Erro ao executar rollback (HTTP $HTTP_STATUS):"
            echo "$ROLLBACK_DATA"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ Rollback executado com sucesso!"
          echo "executed=true" >> $GITHUB_OUTPUT
          
          # Aguarda um pouco para o rollback ser aplicado
          echo "‚è≥ Aguardando rollback ser aplicado..."
          sleep 20
          
          # Testa se o rollback funcionou
          echo "üß™ Verificando se rollback foi bem-sucedido..."
          ROLLBACK_URL="https://$PREV_URL"
          
          if curl -s --connect-timeout 10 --max-time 30 -f "$ROLLBACK_URL" > /dev/null 2>&1; then
            echo "‚úÖ Rollback verificado - aplica√ß√£o est√° respondendo"
          else
            echo "‚ö†Ô∏è Aviso: N√£o foi poss√≠vel verificar o rollback imediatamente"
          fi

      - name: Enviar notifica√ß√£o de rollback
        if: steps.rollback.outputs.executed == 'true'
        run: |
          # Credenciais do Telegram (configuradas)
          BOT_TOKEN="8045408592:AAHtPkn2DTPTrL3rs5lLFbV4vhPDEMAqodw"
          CHAT_ID="5649252463"
          
          DEPLOY_URL="${{ steps.discover.outputs.deploy_url }}"
          PROJECT_NAME="${{ inputs.vercelProject }}"
          
          MESSAGE="üö® *Rollback Executado!*

üèóÔ∏è *Projeto:* $PROJECT_NAME
üìä *Status:* FALHOU
üîÑ *Rollback:* EXECUTADO COM SUCESSO
üåê *URL Original:* $DEPLOY_URL
üìÅ *Repo:* ${{ github.repository }}
üìù *Commit:* ${{ github.sha }}
‚ö†Ô∏è *Motivo:* Health check falhou
‚è∞ *Data:* $(date)

A aplica√ß√£o foi automaticamente revertida para a vers√£o anterior est√°vel."
          
          echo "üì® Enviando notifica√ß√£o de rollback para Telegram..."
          
          curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
            -d "chat_id=$CHAT_ID" \
            -d "text=$MESSAGE" \
            -d "parse_mode=Markdown" || echo "‚ö†Ô∏è Falha ao enviar notifica√ß√£o"

      - name: Resumo final
        if: always()
        run: |
          echo "üìä RESUMO DO DEPLOY"
          echo "===================="
          echo "üèóÔ∏è Projeto: ${{ inputs.vercelProject }}"
          echo "üåê URL: ${{ steps.discover.outputs.deploy_url }}"
          echo "üè• Health Check: ${{ steps.health.outputs.failed == 'true' && '‚ùå FALHOU' || '‚úÖ PASSOU' }}"
          echo "üîÑ Rollback: ${{ steps.rollback.outputs.executed == 'true' && '‚úÖ EXECUTADO' || '‚ùå N√ÉO EXECUTADO' }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üîó Reposit√≥rio: ${{ github.repository }}"
          echo "===================="
          
          if [ "${{ steps.health.outputs.failed }}" = "true" ]; then
            echo "‚ö†Ô∏è ATEN√á√ÉO: Deploy falhou e rollback foi executado!"
            echo "   Verifique os logs acima para detalhes do erro."
            exit 1
          else
            echo "üéâ Deploy realizado com sucesso!"
          fi

  post-deploy-monitoring:
    runs-on: ubuntu-latest
    needs: deploy-and-guard
    if: inputs.enablePostDeployMonitoring && needs.deploy-and-guard.outputs.rollback_executed != 'true'
    steps:
      - name: Monitoramento p√≥s-deploy
        run: |
          echo "üîç Iniciando monitoramento p√≥s-deploy..."
          echo "‚è±Ô∏è  Dura√ß√£o: ${{ inputs.monitoringDurationMinutes }} minutos"
          echo "üîÑ Intervalo: ${{ inputs.monitoringIntervalMinutes }} minutos"
          echo "üåê URL: ${{ needs.deploy-and-guard.outputs.deploy_url }}"
          
          DEPLOY_URL="${{ needs.deploy-and-guard.outputs.deploy_url }}"
          ROUTES="${{ inputs.routes }}"
          TIMEOUT="${{ inputs.healthCheckTimeout }}"
          DURATION_MINUTES="${{ inputs.monitoringDurationMinutes }}"
          INTERVAL_MINUTES="${{ inputs.monitoringIntervalMinutes }}"
          
          # Se n√£o h√° rotas configuradas, detecta automaticamente (vers√£o simplificada)
          if [ -z "$ROUTES" ]; then
            ROUTES="/"
            # Testa rotas comuns rapidamente
            COMMON_ROUTES="/api/health /health /login /dashboard /produtos /carrinho /checkout"
            for route in $COMMON_ROUTES; do
              if curl -s --connect-timeout 3 --max-time 5 -f "$DEPLOY_URL$route" > /dev/null 2>&1; then
                ROUTES="$ROUTES,$route"
              fi
            done
          fi
          
          # Converte para segundos
          DURATION_SECONDS=$((DURATION_MINUTES * 60))
          INTERVAL_SECONDS=$((INTERVAL_MINUTES * 60))
          
          START_TIME=$(date +%s)
          END_TIME=$((START_TIME + DURATION_SECONDS))
          CHECK_COUNT=1
          CONSECUTIVE_FAILURES=0
          MAX_CONSECUTIVE_FAILURES=2
          
          echo "üöÄ Monitoramento iniciado √†s $(date)"
          echo "üèÅ Terminar√° √†s $(date -d @$END_TIME 2>/dev/null || date -r $END_TIME 2>/dev/null || echo 'em $DURATION_MINUTES minutos')"
          
          while [ $(date +%s) -lt $END_TIME ]; do
            CURRENT_TIME=$(date +%s)
            ELAPSED_MINUTES=$(( (CURRENT_TIME - START_TIME) / 60 ))
            REMAINING_MINUTES=$(( (END_TIME - CURRENT_TIME) / 60 ))
            
            echo ""
            echo "üîç Verifica√ß√£o #$CHECK_COUNT (${ELAPSED_MINUTES}m decorridos, ${REMAINING_MINUTES}m restantes)"
            
            FAIL=0
            IFS=',' read -ra ARR <<< "$ROUTES"
            
            for path in "${ARR[@]}"; do
              path=$(echo "$path" | xargs)
              if [[ "$path" != /* ]]; then path="/$path"; fi
              
              url="${DEPLOY_URL}${path}"
              
              # Teste b√°sico de conectividade
              if ! curl -s --connect-timeout 10 --max-time $TIMEOUT -f "$url" > /dev/null 2>&1; then
                echo "‚ùå Falha na conectividade: $path"
                FAIL=1
                continue
              fi
              
              # Teste de status code
              CODE=$(curl -s --connect-timeout 10 --max-time $TIMEOUT -o /dev/null -w "%{http_code}" "$url")
              
              if [ "$CODE" -ge 200 ] && [ "$CODE" -lt 400 ]; then
                echo "‚úÖ $path -> $CODE"
              else
                echo "‚ùå $path -> $CODE (ERRO)"
                FAIL=1
              fi
            done
            
            # Testes adicionais de performance
            RESPONSE_TIME=$(curl -s --connect-timeout 10 --max-time $TIMEOUT -w "%{time_total}" -o /dev/null "$DEPLOY_URL" 2>/dev/null || echo "0")
            
            # Verifica se resposta √© muito lenta (>10s)
            if [ $(echo "$RESPONSE_TIME > 10" | bc -l 2>/dev/null || echo "0") -eq 1 ]; then
              echo "‚ö†Ô∏è  Resposta lenta: ${RESPONSE_TIME}s (>10s)"
              FAIL=1
            else
              echo "‚ö° Tempo de resposta: ${RESPONSE_TIME}s"
            fi
            
            if [ $FAIL -eq 1 ]; then
              CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))
              echo "üö® Falha detectada! (${CONSECUTIVE_FAILURES}/${MAX_CONSECUTIVE_FAILURES} consecutivas)"
              
              if [ $CONSECUTIVE_FAILURES -ge $MAX_CONSECUTIVE_FAILURES ]; then
                echo "üí• M√öLTIPLAS FALHAS CONSECUTIVAS DETECTADAS!"
                echo "üîÑ Iniciando rollback tardio autom√°tico..."
                break
              fi
            else
              echo "‚úÖ Verifica√ß√£o OK"
              CONSECUTIVE_FAILURES=0
            fi
            
            CHECK_COUNT=$((CHECK_COUNT + 1))
            
            # Aguarda pr√≥xima verifica√ß√£o (se n√£o for a √∫ltima)
            if [ $(date +%s) -lt $((END_TIME - INTERVAL_SECONDS)) ]; then
              echo "‚è≥ Aguardando ${INTERVAL_MINUTES} minutos para pr√≥xima verifica√ß√£o..."
              sleep $INTERVAL_SECONDS
            fi
          done
          
          # Verifica se precisa fazer rollback tardio
          if [ $CONSECUTIVE_FAILURES -ge $MAX_CONSECUTIVE_FAILURES ]; then
            echo "üö® EXECUTANDO ROLLBACK TARDIO..."
            
            # Busca informa√ß√µes do projeto
            PROJECT_INFO=$(curl -s -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
              "https://api.vercel.com/v9/projects/${{ inputs.vercelProject }}?teamId=${{ secrets.VERCEL_TEAM_ID }}")
            PROJECT_ID=$(echo "$PROJECT_INFO" | jq -r '.id')
            
            # Busca deployment anterior
            HIST=$(curl -s -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
              "https://api.vercel.com/v6/deployments?teamId=${{ secrets.VERCEL_TEAM_ID }}&projectId=$PROJECT_ID&limit=5&state=READY&target=production")
            PREV_UID=$(echo "$HIST" | jq -r '.deployments[1].uid')
            
            if [ "$PREV_UID" != "null" ] && [ -n "$PREV_UID" ]; then
              curl -s -X POST "https://api.vercel.com/v9/projects/$PROJECT_ID/rollback/$PREV_UID?teamId=${{ secrets.VERCEL_TEAM_ID }}" \
                -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
                -H "Content-Type: application/json"
              
              echo "‚úÖ Rollback tardio executado para deployment $PREV_UID"
              
              # Envia notifica√ß√£o de rollback tardio
              BOT_TOKEN="8045408592:AAHtPkn2DTPTrL3rs5lLFbV4vhPDEMAqodw"
              CHAT_ID="5649252463"
              PROJECT_NAME="${{ inputs.vercelProject }}"
              
              MESSAGE="üö® *Rollback Tardio Executado!*

üèóÔ∏è *Projeto:* $PROJECT_NAME
‚ö†Ô∏è *Motivo:* ${CONSECUTIVE_FAILURES} falhas consecutivas detectadas
‚è±Ô∏è *Tempo at√© falha:* ${ELAPSED_MINUTES} minutos
üåê *URL:* $DEPLOY_URL
üìÅ *Repo:* ${{ github.repository }}
üìù *Commit:* ${{ github.sha }}

Deploy que passou nos testes iniciais apresentou falhas ap√≥s ${ELAPSED_MINUTES} minutos em produ√ß√£o."
              
              curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
                -d "chat_id=$CHAT_ID" \
                -d "text=$MESSAGE" \
                -d "parse_mode=Markdown" || echo "‚ö†Ô∏è Falha ao enviar notifica√ß√£o"
              
              exit 1
            else
              echo "‚ùå N√£o foi poss√≠vel encontrar deployment anterior para rollback"
              exit 1
            fi
          else
            echo "üéâ Monitoramento conclu√≠do com sucesso!"
            echo "‚úÖ Aplica√ß√£o est√°vel por $DURATION_MINUTES minutos"
            
            # Envia notifica√ß√£o de sucesso do monitoramento
            BOT_TOKEN="8045408592:AAHtPkn2DTPTrL3rs5lLFbV4vhPDEMAqodw"
            CHAT_ID="5649252463"
            PROJECT_NAME="${{ inputs.vercelProject }}"
            
            MESSAGE="‚úÖ *Deploy Est√°vel Confirmado!*

üèóÔ∏è *Projeto:* $PROJECT_NAME
‚è±Ô∏è *Monitorado por:* $DURATION_MINUTES minutos
üîç *Verifica√ß√µes:* $((CHECK_COUNT - 1))
üìä *Status:* Est√°vel
üåê *URL:* $DEPLOY_URL

Deploy monitorado sem problemas!"
            
            curl -s -X POST "https://api.telegram.org/bot$BOT_TOKEN/sendMessage" \
              -d "chat_id=$CHAT_ID" \
              -d "text=$MESSAGE" \
              -d "parse_mode=Markdown" || echo "‚ö†Ô∏è Falha ao enviar notifica√ß√£o"
          fi

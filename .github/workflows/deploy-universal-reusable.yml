# üè¢ Deploy Universal Reutiliz√°vel - Para Softhouse
# Usado por TODOS os projetos da empresa

name: Deploy Universal Professional

on:
  workflow_call:
    inputs:
      project_name:
        description: 'Nome do projeto no Vercel'
        required: true
        type: string
      site_url:
        description: 'URL do site (com https://)'
        required: true
        type: string
      environment:
        description: 'Ambiente (production/staging)'
        required: false
        type: string
        default: 'production'
      health_check_timeout:
        description: 'Timeout do health check em segundos'
        required: false
        type: number
        default: 30
      enable_rollback:
        description: 'Ativar rollback autom√°tico'
        required: false
        type: boolean
        default: true
    secrets:
      VERCEL_TOKEN:
        required: true
      VERCEL_TEAM_ID:
        required: true
      VERCEL_SCOPE:
        required: true
      TELEGRAM_BOT_TOKEN:
        required: true
      TELEGRAM_CHAT_ID:
        required: true
    outputs:
      deployment_url:
        description: "URL do deployment"
        value: ${{ jobs.deploy.outputs.preview-url }}
      health_check_status:
        description: "Status do health check"
        value: ${{ jobs.health-check.outputs.health_check_passed }}

jobs:
  # üöÄ DEPLOY
  deploy:
    runs-on: ubuntu-latest
    outputs:
      preview-url: ${{ steps.vercel-deploy.outputs.preview-url }}
      
    steps:
      - name: üì• Checkout
        uses: actions/checkout@v4

      - name: üöÄ Deploy to Vercel
        uses: amondnet/vercel-action@v25
        id: vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ inputs.project_name }}
          vercel-args: '--prod'

      - name: ‚è≥ Aguardar Deploy
        run: |
          echo "‚è≥ Aguardando deploy de ${{ inputs.environment }} ficar dispon√≠vel..."
          echo "üåê Deploy ser√° promovido automaticamente para ${{ inputs.site_url }}"
          sleep 45

      - name: üì± Notificar Deploy Iniciado
        run: |
          MESSAGE="üöÄ Deploy ${{ inputs.environment }} iniciado%0A%0Aüè¢ Projeto: ${{ inputs.project_name }}%0Aüåê Site: ${{ inputs.site_url }}%0Aüìä Commit: ${GITHUB_SHA:0:7}%0Aüë§ Por: ${{ github.actor }}%0A‚è∞ Hor√°rio: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y %H:%M:%S') (Bras√≠lia)%0AüîÑ Aguardando health check..."
          
          # Tentar enviar notifica√ß√£o (n√£o falhar o workflow se der erro)
          if ! curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$MESSAGE"; then
            echo "‚ö†Ô∏è Falha na notifica√ß√£o Telegram - continuando deploy..."
          fi

  # üîç HEALTH CHECK PROFISSIONAL
  health-check:
    runs-on: ubuntu-latest
    needs: deploy
    outputs:
      health_check_passed: ${{ steps.health-check.outputs.health_check_passed }}
      error_details: ${{ steps.health-check.outputs.error_details }}
      status_code: ${{ steps.health-check.outputs.status_code }}
      response_time: ${{ steps.health-check.outputs.response_time }}
      
    steps:
      - name: üîç Health Check Profissional
        id: health-check
        run: |
          echo "üîç INICIANDO HEALTH CHECK PROFISSIONAL..."
          echo "üéØ URL: ${{ inputs.site_url }}"
          echo "‚è∞ Timeout: ${{ inputs.health_check_timeout }}s"
          
          ERRORS=0
          ERROR_DETAILS=""
          
          # 1. AVAILABILITY CHECK
          echo "üìä 1. Testando disponibilidade..."
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total}" --max-time ${{ inputs.health_check_timeout }} "${{ inputs.site_url }}" || echo "HTTPSTATUS:000;TIME:999")
          STATUS=$(echo $RESPONSE | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
          TIME=$(echo $RESPONSE | grep -o "TIME:[0-9.]*" | cut -d: -f2)
          
          echo "üìä Status HTTP: $STATUS"
          echo "‚ö° Tempo resposta: ${TIME}s"
          
          if [[ "$STATUS" != "200" ]]; then
            echo "‚ùå FALHA CR√çTICA: Site n√£o responde (HTTP $STATUS)"
            ERROR_DETAILS="${ERROR_DETAILS}‚Ä¢ HTTP $STATUS (site offline)%0A"
            ERRORS=$((ERRORS + 1))
          elif (( $(echo "$TIME > 5.0" | bc -l 2>/dev/null || echo "0") )); then
            echo "‚ùå FALHA CR√çTICA: Site muito lento (${TIME}s > 5s)"
            ERROR_DETAILS="${ERROR_DETAILS}‚Ä¢ Tempo resposta: ${TIME}s (>5s)%0A"
            ERRORS=$((ERRORS + 1))
          else
            echo "‚úÖ Site dispon√≠vel e r√°pido"
          fi
          
          # 2. BASIC CONTENT CHECK
          echo "üìä 2. Verificando conte√∫do..."
          CONTENT=$(curl -s --max-time ${{ inputs.health_check_timeout }} "${{ inputs.site_url }}" || echo "")
          CONTENT_SIZE=${#CONTENT}
          
          if [[ $CONTENT_SIZE -lt 1000 ]]; then
            echo "‚ùå FALHA CR√çTICA: Conte√∫do muito pequeno ($CONTENT_SIZE chars) - poss√≠vel erro"
            ERROR_DETAILS="${ERROR_DETAILS}‚Ä¢ P√°gina vazia ou erro (${CONTENT_SIZE} chars)%0A"
            ERRORS=$((ERRORS + 1))
          elif echo "$CONTENT" | grep -qi "bailout_to_client_side_rendering"; then
            echo "‚ö†Ô∏è AVISO: Next.js bailout detectado (comportamento normal)"
            echo "‚úÖ Site funcionando para usu√°rios - n√£o √© erro cr√≠tico"
            # N√ÉO incrementar ERRORS - bailout n√£o √© problema real
          elif echo "$CONTENT" | grep -qi "500\|internal server error\|application error\|fatal error\|error occurred\|something went wrong"; then
            echo "‚ùå FALHA CR√çTICA: P√°gina de erro detectada"
            
            # Detailed error logging
            if echo "$CONTENT" | grep -qi "500"; then
              echo "   üîç Erro espec√≠fico: HTTP 500 Internal Server Error"
              ERROR_DETAILS="${ERROR_DETAILS}‚Ä¢ Internal Server Error (500)%0A"
            elif echo "$CONTENT" | grep -qi "fatal error"; then
              echo "   üîç Erro espec√≠fico: Fatal Error detectado"
              ERROR_DETAILS="${ERROR_DETAILS}‚Ä¢ Fatal Error na aplica√ß√£o%0A"
            else
              ERROR_DETAILS="${ERROR_DETAILS}‚Ä¢ P√°gina de erro gen√©rica%0A"
            fi
            
            ERRORS=$((ERRORS + 1))
          else
            echo "‚úÖ Conte√∫do v√°lido (${CONTENT_SIZE} chars)"
          fi
          
          # 3. RESULTADO FINAL
          if [[ $ERRORS -eq 0 ]]; then
            echo "‚úÖ HEALTH CHECK PASSOU - Site funcionando!"
            echo "health_check_passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå HEALTH CHECK FALHOU - $ERRORS erros cr√≠ticos detectados"
            echo "health_check_passed=false" >> $GITHUB_OUTPUT
          fi
          
          # Outputs para outros jobs
          echo "error_details=$ERROR_DETAILS" >> $GITHUB_OUTPUT
          echo "status_code=$STATUS" >> $GITHUB_OUTPUT
          echo "response_time=$TIME" >> $GITHUB_OUTPUT

  # üîÑ ROLLBACK AUTOM√ÅTICO (se habilitado)
  rollback:
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: always() && inputs.enable_rollback && needs.health-check.result == 'failure'
    outputs:
      executed: ${{ steps.rollback.outputs.executed }}
      
    steps:
      - name: üîÑ Rollback Autom√°tico Inteligente
        id: rollback
        run: |
          echo "üö® EXECUTANDO ROLLBACK AUTOM√ÅTICO..."
          echo "Deploy autom√°tico falhou - revertendo para vers√£o anterior"
          
          npm install -g vercel@latest
          
          # üß† ROLLBACK INTELIGENTE - Identifica qual deployment √© o atual vs anterior
          echo "üîç INICIANDO ROLLBACK INTELIGENTE..."
          
          # 1. Pegar o deployment que ACABOU de ser criado (o quebrado)
          echo "üìã 1. Identificando deployment atual (quebrado)..."
          CURRENT_DEPLOYMENT_URL="${{ needs.deploy.outputs.preview-url }}"
          echo "üö® Deployment atual (QUEBRADO): $CURRENT_DEPLOYMENT_URL"
          
          # 2. Listar todos deployments para encontrar o anterior
          echo "üìã 2. Listando todos os deployments..."
          ALL_DEPLOYMENTS=$(npx vercel ls ${{ inputs.project_name }} --token="${{ secrets.VERCEL_TOKEN }}" --scope="${{ secrets.VERCEL_SCOPE }}" -m 20)
          echo "$ALL_DEPLOYMENTS"
          
          # 3. Filtrar apenas deployments Ready de Production (excluindo o atual quebrado)
          echo "üîç 3. Filtrando deployments Ready (excluindo o quebrado)..."
          READY_DEPLOYMENTS=$(echo "$ALL_DEPLOYMENTS" | grep "‚óè Ready" | grep "Production" || true)
          
          # 4. Remover o deployment atual da lista (o quebrado)
          SAFE_DEPLOYMENTS=""
          while IFS= read -r line; do
            if [[ -n "$line" ]]; then
              DEPLOYMENT_URL=$(echo "$line" | awk '{print $1}')
              if [[ "$DEPLOYMENT_URL" != "$CURRENT_DEPLOYMENT_URL" ]]; then
                SAFE_DEPLOYMENTS="$SAFE_DEPLOYMENTS$line"$'\n'
              else
                echo "üö´ Pulando deployment quebrado: $DEPLOYMENT_URL"
              fi
            fi
          done <<< "$READY_DEPLOYMENTS"
          
          echo "‚úÖ Deployments SEGUROS dispon√≠veis:"
          echo "$SAFE_DEPLOYMENTS"
          
          # 5. Pegar o primeiro deployment seguro (mais recente que n√£o √© o quebrado)
          ROLLBACK_URL=$(echo "$SAFE_DEPLOYMENTS" | head -1 | awk '{print $1}')
          
          if [[ -n "$ROLLBACK_URL" && "$ROLLBACK_URL" != "" ]]; then
            echo "üéØ ROLLBACK TARGET IDENTIFICADO: $ROLLBACK_URL"
            echo "üîÑ Executando rollback para deployment seguro..."
            
            npx vercel promote "$ROLLBACK_URL" --token="${{ secrets.VERCEL_TOKEN }}" --scope="${{ secrets.VERCEL_SCOPE }}" --yes
          else
            echo "‚ùå ERRO CR√çTICO: Nenhum deployment seguro encontrado!"
            echo "üîç Poss√≠veis causas:"
            echo "   ‚Ä¢ Todos deployments Ready s√£o o atual (quebrado)"
            echo "   ‚Ä¢ N√£o h√° deployments anteriores Ready"
            echo "   ‚Ä¢ Problema na filtragem dos deployments"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ ROLLBACK EXECUTADO!"
            echo "üß™ Aguardando 30s para estabilizar..."
            sleep 30
            
            # Verificar se funcionou
            ROLLBACK_STATUS=$(curl -s -w "%{http_code}" -o /dev/null --max-time 30 "${{ inputs.site_url }}" || echo "000")
            
            if [[ "$ROLLBACK_STATUS" == "200" ]]; then
              echo "‚úÖ ROLLBACK CONFIRMADO - Site funcionando!"
              echo "executed=true" >> $GITHUB_OUTPUT
            else
              echo "‚ùå ROLLBACK FALHOU - Site ainda com problema (Status: $ROLLBACK_STATUS)"
              echo "executed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå ROLLBACK FALHOU"
            echo "executed=false" >> $GITHUB_OUTPUT
          fi

  # üì± NOTIFICA√á√ÉO FINAL
  notify:
    runs-on: ubuntu-latest
    needs: [deploy, health-check, rollback]
    if: always()
    
    steps:
      - name: üì± Notificar Resultado Final
        run: |
          HEALTH_PASSED="${{ needs.health-check.outputs.health_check_passed }}"
          ERROR_DETAILS="${{ needs.health-check.outputs.error_details }}"
          STATUS_CODE="${{ needs.health-check.outputs.status_code }}"
          RESPONSE_TIME="${{ needs.health-check.outputs.response_time }}"
          ROLLBACK_EXECUTED="${{ needs.rollback.outputs.executed || 'n√£o executado' }}"
          
          if [[ "$HEALTH_PASSED" == "true" ]]; then
            # ‚úÖ SUCESSO
            MESSAGE="‚úÖ ${{ inputs.project_name }} - FUNCIONANDO!%0A%0Aüè¢ Deploy profissional conclu√≠do%0Aüåê Site: ${{ inputs.site_url }}%0Aüìä Status: $STATUS_CODE%0A‚ö° Tempo: ${RESPONSE_TIME}s%0Aüìä Commit: ${GITHUB_SHA:0:7}%0A‚è∞ Conclu√≠do: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y %H:%M:%S') (Bras√≠lia)%0A%0AüéØ Deploy estilo Big Companies!"
          else
            # ‚ùå FALHA
            if [[ "$ROLLBACK_EXECUTED" == "true" ]]; then
              MESSAGE="üîÑ ROLLBACK EXECUTADO!%0A%0Aüè¢ Projeto: ${{ inputs.project_name }}%0Aüö® Deploy falhou mas foi revertido%0A‚úÖ Site funcionando (vers√£o anterior)%0Aüåê ${{ inputs.site_url }}%0Aüìä Status: $STATUS_CODE%0Aüìä Commit: ${GITHUB_SHA:0:7}%0A‚è∞ Rollback: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y %H:%M:%S') (Bras√≠lia)%0A%0A‚úÖ USU√ÅRIOS PROTEGIDOS!"
            else
              MESSAGE="üö® DEPLOY FALHOU!%0A%0Aüè¢ Projeto: ${{ inputs.project_name }}%0A‚ùå Health check falhou%0Aüîç Erro: $ERROR_DETAILS%0Aüìä Status: $STATUS_CODE%0A‚ö° Tempo: ${RESPONSE_TIME}s%0AüîÑ Rollback: $ROLLBACK_EXECUTED%0Aüåê ${{ inputs.site_url }}%0Aüìä Commit: ${GITHUB_SHA:0:7}%0A‚è∞ Falha: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y %H:%M:%S') (Bras√≠lia)%0A%0Aüî• INTERVEN√á√ÉO NECESS√ÅRIA!"
            fi
          fi
          
          # ‚úÖ CURL CORRIGIDO - N√£o falha o workflow se der erro
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$MESSAGE" || echo "‚ö†Ô∏è Notifica√ß√£o Telegram falhou (n√£o cr√≠tico)"

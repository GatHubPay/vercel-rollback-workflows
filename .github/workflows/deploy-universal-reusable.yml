# ğŸ¢ Deploy Universal ReutilizÃ¡vel - Para Softhouse
# Usado por TODOS os projetos da empresa

name: Deploy Universal Professional

on:
  workflow_call:
    inputs:
      project_name:
        description: 'Nome do projeto no Vercel'
        required: true
        type: string
      site_url:
        description: 'URL do site (com https://)'
        required: true
        type: string
      environment:
        description: 'Ambiente (production/staging)'
        required: false
        type: string
        default: 'production'
      health_check_timeout:
        description: 'Timeout do health check em segundos'
        required: false
        type: number
        default: 30
      enable_rollback:
        description: 'Ativar rollback automÃ¡tico'
        required: false
        type: boolean
        default: true
    secrets:
      VERCEL_TOKEN:
        required: true
      VERCEL_TEAM_ID:
        required: true
      VERCEL_SCOPE:
        required: true
      TELEGRAM_BOT_TOKEN:
        required: true
      TELEGRAM_CHAT_ID:
        required: true
    outputs:
      deployment_url:
        description: "URL do deployment"
        value: ${{ jobs.deploy.outputs.preview-url }}
      health_check_status:
        description: "Status do health check"
        value: ${{ jobs.health-check.outputs.health_check_passed }}

jobs:
  # ğŸš€ DEPLOY
  deploy:
    runs-on: ubuntu-latest
    outputs:
      preview-url: ${{ steps.vercel-deploy.outputs.preview-url }}
      
    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ğŸš€ Deploy to Vercel
        uses: amondnet/vercel-action@v25
        id: vercel-deploy
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_TEAM_ID }}
          vercel-project-id: ${{ inputs.project_name }}
          vercel-args: '--prod'

      - name: â³ Aguardar Deploy
        run: |
          echo "â³ Aguardando deploy de ${{ inputs.environment }} ficar disponÃ­vel..."
          echo "ğŸŒ Deploy serÃ¡ promovido automaticamente para ${{ inputs.site_url }}"
          sleep 45

      - name: ğŸ“± Notificar Deploy Iniciado
        run: |
          MESSAGE="ğŸš€ Deploy ${{ inputs.environment }} iniciado%0A%0AğŸ¢ Projeto: ${{ inputs.project_name }}%0AğŸŒ Site: ${{ inputs.site_url }}%0AğŸ“Š Commit: ${GITHUB_SHA:0:7}%0AğŸ‘¤ Por: ${{ github.actor }}%0Aâ° HorÃ¡rio: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y %H:%M:%S') (BrasÃ­lia)%0AğŸ”„ Aguardando health check..."
          
          # Tentar enviar notificaÃ§Ã£o (nÃ£o falhar o workflow se der erro)
          if ! curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$MESSAGE"; then
            echo "âš ï¸ Falha na notificaÃ§Ã£o Telegram - continuando deploy..."
          fi

  # ğŸ” HEALTH CHECK PROFISSIONAL
  health-check:
    runs-on: ubuntu-latest
    needs: deploy
    outputs:
      health_check_passed: ${{ steps.health-check.outputs.health_check_passed }}
      error_details: ${{ steps.health-check.outputs.error_details }}
      status_code: ${{ steps.health-check.outputs.status_code }}
      response_time: ${{ steps.health-check.outputs.response_time }}
      
    steps:
      - name: ğŸ” Health Check Profissional
        id: health-check
        run: |
          echo "ğŸ” INICIANDO HEALTH CHECK PROFISSIONAL..."
          echo "ğŸ¯ URL: ${{ inputs.site_url }}"
          echo "â° Timeout: ${{ inputs.health_check_timeout }}s"
          
          ERRORS=0
          ERROR_DETAILS=""
          
          # 1. AVAILABILITY CHECK
          echo "ğŸ“Š 1. Testando disponibilidade..."
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total}" --max-time ${{ inputs.health_check_timeout }} "${{ inputs.site_url }}" || echo "HTTPSTATUS:000;TIME:999")
          STATUS=$(echo $RESPONSE | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
          TIME=$(echo $RESPONSE | grep -o "TIME:[0-9.]*" | cut -d: -f2)
          
          echo "ğŸ“Š Status HTTP: $STATUS"
          echo "âš¡ Tempo resposta: ${TIME}s"
          
          if [[ "$STATUS" != "200" ]]; then
            echo "âŒ FALHA CRÃTICA: Site nÃ£o responde (HTTP $STATUS)"
            ERROR_DETAILS="${ERROR_DETAILS}â€¢ HTTP $STATUS (site offline)%0A"
            ERRORS=$((ERRORS + 1))
          elif (( $(echo "$TIME > 5.0" | bc -l 2>/dev/null || echo "0") )); then
            echo "âŒ FALHA CRÃTICA: Site muito lento (${TIME}s > 5s)"
            ERROR_DETAILS="${ERROR_DETAILS}â€¢ Tempo resposta: ${TIME}s (>5s)%0A"
            ERRORS=$((ERRORS + 1))
          else
            echo "âœ… Site disponÃ­vel e rÃ¡pido"
          fi
          
          # 2. BASIC CONTENT CHECK
          echo "ğŸ“Š 2. Verificando conteÃºdo..."
          CONTENT=$(curl -s --max-time ${{ inputs.health_check_timeout }} "${{ inputs.site_url }}" || echo "")
          CONTENT_SIZE=${#CONTENT}
          
          if [[ $CONTENT_SIZE -lt 1000 ]]; then
            echo "âŒ FALHA CRÃTICA: ConteÃºdo muito pequeno ($CONTENT_SIZE chars) - possÃ­vel erro"
            ERROR_DETAILS="${ERROR_DETAILS}â€¢ PÃ¡gina vazia ou erro (${CONTENT_SIZE} chars)%0A"
            ERRORS=$((ERRORS + 1))
          elif echo "$CONTENT" | grep -qi "bailout_to_client_side_rendering"; then
            echo "âš ï¸ AVISO: Next.js bailout detectado (comportamento normal)"
            echo "âœ… Site funcionando para usuÃ¡rios - nÃ£o Ã© erro crÃ­tico"
            # NÃƒO incrementar ERRORS - bailout nÃ£o Ã© problema real
          elif echo "$CONTENT" | grep -qi "500\|internal server error\|application error\|fatal error\|error occurred\|something went wrong"; then
            echo "âŒ FALHA CRÃTICA: PÃ¡gina de erro detectada"
            
            # Detailed error logging
            if echo "$CONTENT" | grep -qi "500"; then
              echo "   ğŸ” Erro especÃ­fico: HTTP 500 Internal Server Error"
              ERROR_DETAILS="${ERROR_DETAILS}â€¢ Internal Server Error (500)%0A"
            elif echo "$CONTENT" | grep -qi "fatal error"; then
              echo "   ğŸ” Erro especÃ­fico: Fatal Error detectado"
              ERROR_DETAILS="${ERROR_DETAILS}â€¢ Fatal Error na aplicaÃ§Ã£o%0A"
            else
              ERROR_DETAILS="${ERROR_DETAILS}â€¢ PÃ¡gina de erro genÃ©rica%0A"
            fi
            
            ERRORS=$((ERRORS + 1))
          else
            echo "âœ… ConteÃºdo vÃ¡lido (${CONTENT_SIZE} chars)"
          fi
          
          # 3. RESULTADO FINAL
          if [[ $ERRORS -eq 0 ]]; then
            echo "âœ… HEALTH CHECK PASSOU - Site funcionando!"
            echo "health_check_passed=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ HEALTH CHECK FALHOU - $ERRORS erros crÃ­ticos detectados"
            echo "health_check_passed=false" >> $GITHUB_OUTPUT
          fi
          
          # Outputs para outros jobs
          echo "error_details=$ERROR_DETAILS" >> $GITHUB_OUTPUT
          echo "status_code=$STATUS" >> $GITHUB_OUTPUT
          echo "response_time=$TIME" >> $GITHUB_OUTPUT

  # ğŸ”„ ROLLBACK AUTOMÃTICO (se habilitado)
  rollback:
    runs-on: ubuntu-latest
    needs: [deploy, health-check]
    if: always() && inputs.enable_rollback && needs.health-check.result == 'failure'
    outputs:
      executed: ${{ steps.rollback.outputs.executed }}
      
    steps:
      - name: ğŸ”„ Rollback AutomÃ¡tico Inteligente
        id: rollback
        run: |
          echo "ğŸš¨ EXECUTANDO ROLLBACK AUTOMÃTICO..."
          echo "Deploy automÃ¡tico falhou - revertendo para versÃ£o anterior"
          
          npm install -g vercel@latest
          
          # ğŸ§  ROLLBACK INTELIGENTE - Identifica qual deployment Ã© o atual vs anterior
          echo "ğŸ” INICIANDO ROLLBACK INTELIGENTE..."
          
          # 1. Pegar o deployment que ACABOU de ser criado (o quebrado)
          echo "ğŸ“‹ 1. Identificando deployment atual (quebrado)..."
          CURRENT_DEPLOYMENT_URL="${{ needs.deploy.outputs.preview-url }}"
          echo "ğŸš¨ Deployment atual (QUEBRADO): $CURRENT_DEPLOYMENT_URL"
          
          # 2. Listar todos deployments para encontrar o anterior
          echo "ğŸ“‹ 2. Listando todos os deployments..."
          ALL_DEPLOYMENTS=$(npx vercel ls ${{ inputs.project_name }} --token="${{ secrets.VERCEL_TOKEN }}" --scope="${{ secrets.VERCEL_SCOPE }}" -m 20)
          echo "$ALL_DEPLOYMENTS"
          
          # 3. Filtrar apenas deployments Ready de Production (excluindo o atual quebrado)
          echo "ğŸ” 3. Filtrando deployments Ready (excluindo o quebrado)..."
          READY_DEPLOYMENTS=$(echo "$ALL_DEPLOYMENTS" | grep "â— Ready" | grep "Production" || true)
          
          # 4. Remover o deployment atual da lista (o quebrado)
          SAFE_DEPLOYMENTS=""
          while IFS= read -r line; do
            if [[ -n "$line" ]]; then
              DEPLOYMENT_URL=$(echo "$line" | awk '{print $1}')
              if [[ "$DEPLOYMENT_URL" != "$CURRENT_DEPLOYMENT_URL" ]]; then
                SAFE_DEPLOYMENTS="$SAFE_DEPLOYMENTS$line"$'\n'
              else
                echo "ğŸš« Pulando deployment quebrado: $DEPLOYMENT_URL"
              fi
            fi
          done <<< "$READY_DEPLOYMENTS"
          
          echo "âœ… Deployments SEGUROS disponÃ­veis:"
          echo "$SAFE_DEPLOYMENTS"
          
          # 5. Pegar o primeiro deployment seguro (mais recente que nÃ£o Ã© o quebrado)
          ROLLBACK_URL=$(echo "$SAFE_DEPLOYMENTS" | head -1 | awk '{print $1}')
          
          if [[ -n "$ROLLBACK_URL" && "$ROLLBACK_URL" != "" ]]; then
            echo "ğŸ¯ ROLLBACK TARGET IDENTIFICADO: $ROLLBACK_URL"
            echo "ğŸ”„ Executando rollback para deployment seguro..."
            
            npx vercel promote "$ROLLBACK_URL" --token="${{ secrets.VERCEL_TOKEN }}" --scope="${{ secrets.VERCEL_SCOPE }}" --yes
          else
            echo "âŒ ERRO CRÃTICO: Nenhum deployment seguro encontrado!"
            echo "ğŸ” PossÃ­veis causas:"
            echo "   â€¢ Todos deployments Ready sÃ£o o atual (quebrado)"
            echo "   â€¢ NÃ£o hÃ¡ deployments anteriores Ready"
            echo "   â€¢ Problema na filtragem dos deployments"
            echo "executed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          if [ $? -eq 0 ]; then
            echo "âœ… ROLLBACK EXECUTADO!"
            echo "ğŸ§ª Aguardando 30s para estabilizar..."
            sleep 30
            
            # Verificar se funcionou
            ROLLBACK_STATUS=$(curl -s -w "%{http_code}" -o /dev/null --max-time 30 "${{ inputs.site_url }}" || echo "000")
            
            if [[ "$ROLLBACK_STATUS" == "200" ]]; then
              echo "âœ… ROLLBACK CONFIRMADO - Site funcionando!"
              echo "executed=true" >> $GITHUB_OUTPUT
            else
              echo "âŒ ROLLBACK FALHOU - Site ainda com problema (Status: $ROLLBACK_STATUS)"
              echo "executed=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "âŒ ROLLBACK FALHOU"
            echo "executed=false" >> $GITHUB_OUTPUT
          fi

  # ğŸ“± NOTIFICAÃ‡ÃƒO FINAL
  notify:
    runs-on: ubuntu-latest
    needs: [deploy, health-check, rollback]
    if: always()
    
    steps:
      - name: ğŸ“± Notificar Resultado Final
        run: |
          HEALTH_PASSED="${{ needs.health-check.outputs.health_check_passed }}"
          ERROR_DETAILS="${{ needs.health-check.outputs.error_details }}"
          STATUS_CODE="${{ needs.health-check.outputs.status_code }}"
          RESPONSE_TIME="${{ needs.health-check.outputs.response_time }}"
          ROLLBACK_EXECUTED="${{ needs.rollback.outputs.executed || 'nÃ£o executado' }}"
          
          if [[ "$HEALTH_PASSED" == "true" ]]; then
            # âœ… SUCESSO
            MESSAGE="âœ… ${{ inputs.project_name }} - FUNCIONANDO!%0A%0AğŸ¢ Deploy profissional concluÃ­do%0AğŸŒ Site: ${{ inputs.site_url }}%0AğŸ“Š Status: $STATUS_CODE%0Aâš¡ Tempo: ${RESPONSE_TIME}s%0AğŸ“Š Commit: ${GITHUB_SHA:0:7}%0Aâ° ConcluÃ­do: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y %H:%M:%S') (BrasÃ­lia)%0A%0AğŸ¯ Deploy estilo Big Companies!"
          else
            # âŒ FALHA
            if [[ "$ROLLBACK_EXECUTED" == "true" ]]; then
              MESSAGE="ğŸ”„ ROLLBACK EXECUTADO!%0A%0AğŸ¢ Projeto: ${{ inputs.project_name }}%0AğŸš¨ Deploy falhou mas foi revertido%0Aâœ… Site funcionando (versÃ£o anterior)%0AğŸŒ ${{ inputs.site_url }}%0AğŸ“Š Status: $STATUS_CODE%0AğŸ“Š Commit: ${GITHUB_SHA:0:7}%0Aâ° Rollback: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y %H:%M:%S') (BrasÃ­lia)%0A%0Aâœ… USUÃRIOS PROTEGIDOS!"
            else
              MESSAGE="ğŸš¨ DEPLOY FALHOU!%0A%0AğŸ¢ Projeto: ${{ inputs.project_name }}%0AâŒ Health check falhou%0AğŸ” Erro: $ERROR_DETAILS%0AğŸ“Š Status: $STATUS_CODE%0Aâš¡ Tempo: ${RESPONSE_TIME}s%0AğŸ”„ Rollback: $ROLLBACK_EXECUTED%0AğŸŒ ${{ inputs.site_url }}%0AğŸ“Š Commit: ${GITHUB_SHA:0:7}%0Aâ° Falha: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y %H:%M:%S') (BrasÃ­lia)%0A%0AğŸ”¥ INTERVENÃ‡ÃƒO NECESSÃRIA!"
            fi
          fi
          
          # âœ… CURL CORRIGIDO - NÃ£o falha o workflow se der erro
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$MESSAGE" || echo "âš ï¸ NotificaÃ§Ã£o Telegram falhou (nÃ£o crÃ­tico)"

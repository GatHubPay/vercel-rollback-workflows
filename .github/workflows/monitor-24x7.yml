# ğŸš¨ Monitoramento 24/7 - Todos os Sites da GatHubPay
# Monitora TODOS os sites a cada 15 minutos

name: Monitor 24/7

on:
  schedule:
    - cron: '*/5 * * * *'   # A cada 5 minutos (padrÃ£o big companies)
  workflow_dispatch:         # Permite executar manualmente

jobs:
  monitor-sites:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        # ğŸ¯ TODOS OS SEUS SITES:
        site:
          - name: "rasparei"
            url: "https://rasparei.com/"
            timeout: 10
          # - name: "admin-raspaganha"
          #   url: "https://admin.raspaganha.sa.com/"
          #   timeout: 15
          # - name: "raspaganha-v2"
          #   url: "https://raspaganha-v2.vercel.app/"
          #   timeout: 10
          # â• Adicione seus outros 7+ sites aqui conforme necessÃ¡rio
      fail-fast: false  # Continua testando outros sites mesmo se um falhar
    
    steps:
      - name: ğŸ” Monitorar ${{ matrix.site.name }}
        run: |
          echo "ğŸ” Verificando ${{ matrix.site.name }}..."
          echo "ğŸŒ URL: ${{ matrix.site.url }}"
          
          # Health check completo
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total};SIZE:%{size_download}" \
                         --max-time ${{ matrix.site.timeout }} \
                         "${{ matrix.site.url }}" || echo "HTTPSTATUS:000;TIME:999;SIZE:0")
          
          STATUS=$(echo $RESPONSE | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
          TIME=$(echo $RESPONSE | grep -o "TIME:[0-9.]*" | cut -d: -f2)
          SIZE=$(echo $RESPONSE | grep -o "SIZE:[0-9]*" | cut -d: -f2)
          
          # Capturar conteÃºdo da pÃ¡gina para anÃ¡lise de erros
          CONTENT=$(curl -s --max-time ${{ matrix.site.timeout }} "${{ matrix.site.url }}" || echo "")
          
          echo "ğŸ“Š Status: $STATUS"
          echo "âš¡ Tempo: ${TIME}s"
          echo "ğŸ“„ Tamanho: $SIZE bytes"
          
          # Verificar problemas
          PROBLEMS=""
          ALERT_LEVEL="info"
          
          if [[ "$STATUS" == "000" ]]; then
            PROBLEMS="${PROBLEMS}â€¢ DomÃ­nio nÃ£o resolve ou servidor offline%0A"
            ALERT_LEVEL="critical"
            echo "ğŸš¨ CRÃTICO: DomÃ­nio/Servidor completamente fora do ar"
          elif [[ "$STATUS" != "200" ]]; then
            PROBLEMS="${PROBLEMS}â€¢ HTTP $STATUS (erro no servidor)%0A"
            ALERT_LEVEL="critical"
            echo "ğŸš¨ CRÃTICO: Servidor respondendo com erro $STATUS"
          elif [[ "$SIZE" -lt 1000 ]]; then
            PROBLEMS="${PROBLEMS}â€¢ PÃ¡gina muito pequena (${SIZE} bytes)%0A"
            ALERT_LEVEL="warning"
          elif (( $(echo "$TIME > 3.0" | bc -l 2>/dev/null || echo "0") )); then
            PROBLEMS="${PROBLEMS}â€¢ Site muito lento (${TIME}s) - limite big companies%0A"
            ALERT_LEVEL="critical"
            echo "ğŸš¨ CRÃTICO: Site muito lento - acima do padrÃ£o profissional (3s)"
          elif (( $(echo "$TIME > 2.0" | bc -l 2>/dev/null || echo "0") )); then
            PROBLEMS="${PROBLEMS}â€¢ Site lento (${TIME}s) - monitorar performance%0A"
            ALERT_LEVEL="warning"
            echo "âš ï¸ AVISO: Site mais lento que o ideal (2s)"
          fi
          
          # ğŸš¨ VERIFICAR ERROS ESPECÃFICOS NO CONTEÃšDO (apenas se status nÃ£o for 200)
          if [[ "$STATUS" != "200" ]] && echo "$CONTENT" | grep -qi "application error\|client-side exception\|internal server error\|fatal error\|error occurred\|something went wrong\|service unavailable"; then
            if echo "$CONTENT" | grep -qi "application error.*client-side exception"; then
              PROBLEMS="${PROBLEMS}â€¢ Application Error detectado%0A"
              echo "ğŸš¨ ERRO DETECTADO: Application Error (client-side exception)"
            elif echo "$CONTENT" | grep -qi "internal server error"; then
              PROBLEMS="${PROBLEMS}â€¢ Internal Server Error detectado%0A"
              echo "ğŸš¨ ERRO DETECTADO: Internal Server Error"
            elif echo "$CONTENT" | grep -qi "fatal error"; then
              PROBLEMS="${PROBLEMS}â€¢ Fatal Error na aplicaÃ§Ã£o%0A"
              echo "ğŸš¨ ERRO DETECTADO: Fatal Error"
            else
              PROBLEMS="${PROBLEMS}â€¢ Erro genÃ©rico detectado%0A"
              echo "ğŸš¨ ERRO DETECTADO: Erro genÃ©rico na pÃ¡gina"
            fi
            ALERT_LEVEL="critical"
          elif [[ "$STATUS" == "200" ]] && echo "$CONTENT" | grep -qi "application error.*has occurred\|fatal error.*occurred\|internal server error.*occurred"; then
            # SÃ³ detectar erros REAIS quando status Ã© 200 (frases completas de erro)
            PROBLEMS="${PROBLEMS}â€¢ Erro real detectado na pÃ¡gina%0A"
            ALERT_LEVEL="critical"
            echo "ğŸš¨ ERRO REAL: PÃ¡gina com erro mesmo tendo status 200"
          fi
          
          # Enviar alerta se houver problema
          if [[ -n "$PROBLEMS" ]]; then
            if [[ "$ALERT_LEVEL" == "critical" ]]; then
              EMOJI="ğŸš¨"
              TITLE="SITE OFFLINE"
            else
              EMOJI="âš ï¸"
              TITLE="PROBLEMA DETECTADO"
            fi
            
            MESSAGE="$EMOJI $TITLE - ${{ matrix.site.name }}%0A%0AğŸŒ Site: ${{ matrix.site.url }}%0AğŸ“Š Status: $STATUS%0Aâš¡ Tempo: ${TIME}s%0AğŸ“„ Tamanho: $SIZE bytes%0AğŸ“… Data: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y')%0Aâ° Hora: $(TZ='America/Sao_Paulo' date '+%H:%M:%S') (BrasÃ­lia)%0A%0AğŸ” Problemas:%0A$PROBLEMS%0AğŸ”¥ VERIFICAR URGENTE!"
            
            # Enviar alerta imediato
            curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d "text=$MESSAGE" || echo "âš ï¸ Falha ao enviar alerta"
            
            echo "ğŸš¨ ALERTA ENVIADO para ${{ matrix.site.name }}!"
            exit 1  # Falha o job para aparecer no GitHub
          else
            echo "âœ… ${{ matrix.site.name }} funcionando normalmente"
          fi

  # ğŸš€ MONITORAMENTO DE TRÃFEGO VERCEL - Detecta Picos de Acesso
  monitor-vercel-traffic:
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ” Detectar TODOS os Projetos Vercel Automaticamente
        id: traffic-check
        run: |
          echo "ğŸš€ Detectando TODOS os projetos Vercel automaticamente..."
          
          # ConfiguraÃ§Ãµes da Vercel (adicione esses secrets no GitHub)
          VERCEL_TOKEN="${{ secrets.VERCEL_TOKEN }}"
          VERCEL_TEAM_ID="${{ secrets.VERCEL_TEAM_ID }}"
          
          if [[ -z "$VERCEL_TOKEN" ]]; then
            echo "âš ï¸ VERCEL_TOKEN nÃ£o configurado - usando lista estÃ¡tica"
            # Fallback para lista estÃ¡tica se nÃ£o tiver token
            PROJECTS=(
              "rasparei|https://rasparei.com/|10"
              "admin-raspaganha|https://admin.raspaganha.sa.com/|15"
              "raspaganha-v2|https://raspaganha-v2.vercel.app/|10"
            )
          else
            echo "ğŸ”‘ Usando API da Vercel para detectar projetos automaticamente..."
            
            # Buscar todos os projetos da equipe
            if [[ -n "$VERCEL_TEAM_ID" ]]; then
              PROJECTS_JSON=$(curl -s -H "Authorization: Bearer $VERCEL_TOKEN" \
                "https://api.vercel.com/v1/teams/$VERCEL_TEAM_ID/projects" || echo "[]")
            else
              PROJECTS_JSON=$(curl -s -H "Authorization: Bearer $VERCEL_TOKEN" \
                "https://api.vercel.com/v1/projects" || echo "[]")
            fi
            
            # Extrair domÃ­nios de todos os projetos
            PROJECTS=()
            echo "$PROJECTS_JSON" | jq -r '.projects[]? | select(.domains != null) | .domains[]? | select(.verified == true) | .name' 2>/dev/null | while read -r domain; do
              if [[ -n "$domain" ]]; then
                # Adicionar timeout baseado no tipo de domÃ­nio
                if [[ "$domain" == *"admin"* ]] || [[ "$domain" == *"dashboard"* ]]; then
                  timeout="15"
                elif [[ "$domain" == *"canary"* ]] || [[ "$domain" == *"staging"* ]] || [[ "$domain" == *"dev"* ]]; then
                  timeout="8"
                else
                  timeout="10"
                fi
                
                PROJECTS+=("$domain|https://$domain/|$timeout")
                echo "ğŸŒ Detectado: $domain (timeout: ${timeout}s)"
              fi
            done
            
            # Se nÃ£o conseguiu detectar via API, usar fallback
            if [[ ${#PROJECTS[@]} -eq 0 ]]; then
              echo "âš ï¸ Falha na API - usando lista estÃ¡tica"
              PROJECTS=(
                "rasparei|https://rasparei.com/|10"
                "admin-raspaganha|https://admin.raspaganha.sa.com/|15"
                "raspaganha-v2|https://raspaganha-v2.vercel.app/|10"
              )
            fi
          fi
          
          # Contadores para anÃ¡lise
          HIGH_TRAFFIC_COUNT=0
          PROBLEM_PROJECTS=""
          TOTAL_PROJECTS=${#PROJECTS[@]}
          
          echo "ğŸ“Š Total de projetos detectados: $TOTAL_PROJECTS"
          
          # Verificar cada projeto
          for project in "${PROJECTS[@]}"; do
            IFS='|' read -r project_name url timeout <<< "$project"
            
            echo "ğŸŒ Verificando $project_name..."
            
            # Health check + anÃ¡lise de trÃ¡fego
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total};SIZE:%{size_download}" \
                           --max-time $timeout \
                           "$url" || echo "HTTPSTATUS:000;TIME:999;SIZE:0")
            
            STATUS=$(echo $RESPONSE | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
            TIME=$(echo $RESPONSE | grep -o "TIME:[0-9.]*" | cut -d: -f2)
            SIZE=$(echo $RESPONSE | grep -o "SIZE:[0-9]*" | cut -d: -f2)
            
            # Detectar problemas de trÃ¡fego
            TRAFFIC_ISSUE=""
            if [[ "$STATUS" == "000" ]]; then
              TRAFFIC_ISSUE="ğŸš¨ OFFLINE - PossÃ­vel sobrecarga"
              HIGH_TRAFFIC_COUNT=$((HIGH_TRAFFIC_COUNT + 1))
            elif [[ "$STATUS" != "200" ]]; then
              TRAFFIC_ISSUE="âš ï¸ ERRO $STATUS - PossÃ­vel sobrecarga"
              HIGH_TRAFFIC_COUNT=$((HIGH_TRAFFIC_COUNT + 1))
            elif (( $(echo "$TIME > 5.0" | bc -l 2>/dev/null || echo "0") )); then
              TRAFFIC_ISSUE="ğŸ”¥ ALTO TRÃFEGO - ${TIME}s"
              HIGH_TRAFFIC_COUNT=$((HIGH_TRAFFIC_COUNT + 1))
            elif (( $(echo "$TIME > 3.0" | bc -l 2>/dev/null || echo "0") )); then
              TRAFFIC_ISSUE="âš ï¸ TRÃFEGO ELEVADO - ${TIME}s"
            fi
            
            if [[ -n "$TRAFFIC_ISSUE" ]]; then
              PROBLEM_PROJECTS="${PROBLEM_PROJECTS}â€¢ $project_name: $TRAFFIC_ISSUE%0A"
            fi
            
            echo "   ğŸ“Š Status: $STATUS | âš¡ Tempo: ${TIME}s | ğŸ“„ Tamanho: $SIZE bytes | $TRAFFIC_ISSUE"
          done
          
          # Salvar resultados para uso posterior
          echo "high_traffic_count=$HIGH_TRAFFIC_COUNT" >> $GITHUB_OUTPUT
          echo "problem_projects=$PROBLEM_PROJECTS" >> $GITHUB_OUTPUT
          echo "total_projects=$TOTAL_PROJECTS" >> $GITHUB_OUTPUT
          
          echo "ğŸ“Š Resumo: $HIGH_TRAFFIC_COUNT/$TOTAL_PROJECTS com problemas de trÃ¡fego"
      
      - name: ğŸ†• Detectar Novos DomÃ­nios e Notificar
        if: steps.traffic-check.outputs.total_projects > 0
        run: |
          echo "ğŸ†• Verificando se hÃ¡ novos domÃ­nios..."
          
          # Comparar com lista anterior (se existir)
          CURRENT_DOMAINS=$(echo "${{ steps.traffic-check.outputs.problem_projects }}" | grep -o '[^|]*' | head -1)
          
          # Salvar lista atual para prÃ³xima comparaÃ§Ã£o
          echo "$CURRENT_DOMAINS" > /tmp/current_domains.txt
          
          # Se for primeira execuÃ§Ã£o, nÃ£o notificar
          if [[ ! -f /tmp/previous_domains.txt ]]; then
            echo "ğŸ“ Primeira execuÃ§Ã£o - salvando lista de domÃ­nios"
            cp /tmp/current_domains.txt /tmp/previous_domains.txt
            exit 0
          fi
          
          # Comparar domÃ­nios atuais com anteriores
          NEW_DOMAINS=$(comm -13 /tmp/previous_domains.txt /tmp/current_domains.txt | grep -v '^$')
          
          if [[ -n "$NEW_DOMAINS" ]]; then
            echo "ğŸ†• Novos domÃ­nios detectados:"
            echo "$NEW_DOMAINS"
            
            # Notificar sobre novos domÃ­nios
            MESSAGE="ğŸ†• NOVOS DOMÃNIOS DETECTADOS!%0A%0AğŸŒ Novos projetos:%0A"
            
            while IFS= read -r domain; do
              if [[ -n "$domain" ]]; then
                MESSAGE="${MESSAGE}â€¢ $domain%0A"
              fi
            done <<< "$NEW_DOMAINS"
            
            MESSAGE="${MESSAGE}%0AğŸ“… Data: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y')%0Aâ° Hora: $(TZ='America/Sao_Paulo' date '+%H:%M:%S') (BrasÃ­lia)%0A%0Aâœ… Monitoramento automÃ¡tico ativado!"
            
            # Enviar notificaÃ§Ã£o
            curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d "text=$MESSAGE" || echo "âš ï¸ Falha ao notificar novos domÃ­nios"
            
            echo "ğŸ†• NotificaÃ§Ã£o de novos domÃ­nios enviada!"
          else
            echo "âœ… Nenhum novo domÃ­nio detectado"
          fi
          
          # Atualizar lista anterior
          cp /tmp/current_domains.txt /tmp/previous_domains.txt
      
      - name: ğŸš¨ Alerta de Alto TrÃ¡fego SimultÃ¢neo
        if: steps.traffic-check.outputs.high_traffic_count >= 1
        run: |
          echo "ğŸš¨ ALERTA: Projeto com problema de trÃ¡fego detectado!"
          
          MESSAGE="ğŸš¨ ALERTA DE TRÃFEGO VERCEL%0A%0AğŸ”¥ ${{ steps.traffic-check.outputs.high_traffic_count }}/${{ steps.traffic-check.outputs.total_projects }} projetos com problemas%0A%0AğŸ“Š DOMÃNIOS AFETADOS:%0A${{ steps.traffic-check.outputs.problem_projects }}%0AğŸ“… Data: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y')%0Aâ° Hora: $(TZ='America/Sao_Paulo' date '+%H:%M:%S') (BrasÃ­lia)%0A%0AğŸš¨ VERIFICAR DOMÃNIO AFETADO URGENTE!"
          
          # Enviar alerta crÃ­tico para Telegram
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$MESSAGE" || echo "âš ï¸ Falha ao enviar alerta"
          
          echo "ğŸš¨ Alerta de alto trÃ¡fego enviado!"
      
      - name: ğŸ“Š RelatÃ³rio de TrÃ¡fego
        if: always()
        run: |
          echo "ğŸ“Š RelatÃ³rio de TrÃ¡fego Vercel"
          echo "â° VerificaÃ§Ã£o: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "ğŸ¯ Total de projetos: ${{ steps.traffic-check.outputs.total_projects }}"
          echo "ğŸš¨ Projetos com problemas: ${{ steps.traffic-check.outputs.high_traffic_count }}"
          
          if [[ "${{ steps.traffic-check.outputs.high_traffic_count }}" -ge 1 ]]; then
            echo "ğŸš¨ ALERTA ATIVO: ${{ steps.traffic-check.outputs.high_traffic_count }} projeto(s) com problemas!"
            echo "ğŸ“Š DomÃ­nios afetados:"
            echo "${{ steps.traffic-check.outputs.problem_projects }}"
          else
            echo "âœ… TrÃ¡fego normal em todos os projetos"
          fi

  # ğŸ“Š RESUMO GERAL (executa sempre, mesmo se sites falharem)
  summary:
    runs-on: ubuntu-latest
    needs: [monitor-sites, monitor-vercel-traffic]
    if: always()
    
    steps:
      - name: ğŸ“Š Resumo do Monitoramento
        run: |
          echo "ğŸ“Š Monitoramento 24/7 + TrÃ¡fego Vercel executado"
          echo "â° HorÃ¡rio: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # Em caso de falhas, o GitHub Actions jÃ¡ mostra no dashboard
          # Aqui vocÃª pode adicionar lÃ³gica para contar sucessos/falhas
          
          echo "âœ… PrÃ³xima verificaÃ§Ã£o em 5 minutos"
          echo "ğŸš€ Monitoramento de trÃ¡fego Vercel ativo"

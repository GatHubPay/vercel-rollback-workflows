# üö® Monitoramento 24/7 - Todos os Sites da GatHubPay
# Monitora TODOS os sites a cada 15 minutos

name: Monitor 24/7

on:
  schedule:
    - cron: '*/5 * * * *'   # A cada 5 minutos (padr√£o big companies)
  workflow_dispatch:         # Permite executar manualmente

jobs:
  monitor-sites:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        # üéØ TODOS OS SEUS SITES:
        site:
          - name: "rasparei"
            url: "https://rasparei.com/"
            timeout: 10
          # - name: "admin-raspaganha"
          #   url: "https://admin.raspaganha.sa.com/"
          #   timeout: 15
          # - name: "raspaganha-v2"
          #   url: "https://raspaganha-v2.vercel.app/"
          #   timeout: 10
          # ‚ûï Adicione seus outros 7+ sites aqui conforme necess√°rio
      fail-fast: false  # Continua testando outros sites mesmo se um falhar
    
    steps:
      - name: üîç Monitorar ${{ matrix.site.name }}
        run: |
          echo "üîç Verificando ${{ matrix.site.name }}..."
          echo "üåê URL: ${{ matrix.site.url }}"
          
          # Health check completo
          RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total};SIZE:%{size_download}" \
                         --max-time ${{ matrix.site.timeout }} \
                         "${{ matrix.site.url }}" || echo "HTTPSTATUS:000;TIME:999;SIZE:0")
          
          STATUS=$(echo $RESPONSE | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
          TIME=$(echo $RESPONSE | grep -o "TIME:[0-9.]*" | cut -d: -f2)
          SIZE=$(echo $RESPONSE | grep -o "SIZE:[0-9]*" | cut -d: -f2)
          
          # Capturar conte√∫do da p√°gina para an√°lise de erros
          CONTENT=$(curl -s --max-time ${{ matrix.site.timeout }} "${{ matrix.site.url }}" || echo "")
          
          echo "üìä Status: $STATUS"
          echo "‚ö° Tempo: ${TIME}s"
          echo "üìÑ Tamanho: $SIZE bytes"
          
          # Verificar problemas
          PROBLEMS=""
          ALERT_LEVEL="info"
          
          if [[ "$STATUS" == "000" ]]; then
            PROBLEMS="${PROBLEMS}‚Ä¢ Dom√≠nio n√£o resolve ou servidor offline%0A"
            ALERT_LEVEL="critical"
            echo "üö® CR√çTICO: Dom√≠nio/Servidor completamente fora do ar"
          elif [[ "$STATUS" != "200" ]]; then
            PROBLEMS="${PROBLEMS}‚Ä¢ HTTP $STATUS (erro no servidor)%0A"
            ALERT_LEVEL="critical"
            echo "üö® CR√çTICO: Servidor respondendo com erro $STATUS"
          elif [[ "$SIZE" -lt 1000 ]]; then
            PROBLEMS="${PROBLEMS}‚Ä¢ P√°gina muito pequena (${SIZE} bytes)%0A"
            ALERT_LEVEL="warning"
          elif (( $(echo "$TIME > 3.0" | bc -l 2>/dev/null || echo "0") )); then
            PROBLEMS="${PROBLEMS}‚Ä¢ Site muito lento (${TIME}s) - limite big companies%0A"
            ALERT_LEVEL="critical"
            echo "üö® CR√çTICO: Site muito lento - acima do padr√£o profissional (3s)"
          elif (( $(echo "$TIME > 2.0" | bc -l 2>/dev/null || echo "0") )); then
            PROBLEMS="${PROBLEMS}‚Ä¢ Site lento (${TIME}s) - monitorar performance%0A"
            ALERT_LEVEL="warning"
            echo "‚ö†Ô∏è AVISO: Site mais lento que o ideal (2s)"
          fi
          
          # üö® VERIFICAR ERROS ESPEC√çFICOS NO CONTE√öDO (apenas se status n√£o for 200)
          if [[ "$STATUS" != "200" ]] && echo "$CONTENT" | grep -qi "application error\|client-side exception\|internal server error\|fatal error\|error occurred\|something went wrong\|service unavailable"; then
            if echo "$CONTENT" | grep -qi "application error.*client-side exception"; then
              PROBLEMS="${PROBLEMS}‚Ä¢ Application Error detectado%0A"
              echo "üö® ERRO DETECTADO: Application Error (client-side exception)"
            elif echo "$CONTENT" | grep -qi "internal server error"; then
              PROBLEMS="${PROBLEMS}‚Ä¢ Internal Server Error detectado%0A"
              echo "üö® ERRO DETECTADO: Internal Server Error"
            elif echo "$CONTENT" | grep -qi "fatal error"; then
              PROBLEMS="${PROBLEMS}‚Ä¢ Fatal Error na aplica√ß√£o%0A"
              echo "üö® ERRO DETECTADO: Fatal Error"
            else
              PROBLEMS="${PROBLEMS}‚Ä¢ Erro gen√©rico detectado%0A"
              echo "üö® ERRO DETECTADO: Erro gen√©rico na p√°gina"
            fi
            ALERT_LEVEL="critical"
          elif [[ "$STATUS" == "200" ]] && echo "$CONTENT" | grep -qi "application error.*has occurred\|fatal error.*occurred\|internal server error.*occurred"; then
            # S√≥ detectar erros REAIS quando status √© 200 (frases completas de erro)
            PROBLEMS="${PROBLEMS}‚Ä¢ Erro real detectado na p√°gina%0A"
            ALERT_LEVEL="critical"
            echo "üö® ERRO REAL: P√°gina com erro mesmo tendo status 200"
          fi
          
          # Enviar alerta se houver problema
          if [[ -n "$PROBLEMS" ]]; then
            if [[ "$ALERT_LEVEL" == "critical" ]]; then
              EMOJI="üö®"
              TITLE="SITE OFFLINE"
            else
              EMOJI="‚ö†Ô∏è"
              TITLE="PROBLEMA DETECTADO"
            fi
            
            MESSAGE="$EMOJI $TITLE - ${{ matrix.site.name }}%0A%0Aüåê Site: ${{ matrix.site.url }}%0Aüìä Status: $STATUS%0A‚ö° Tempo: ${TIME}s%0AüìÑ Tamanho: $SIZE bytes%0AüìÖ Data: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y')%0A‚è∞ Hora: $(TZ='America/Sao_Paulo' date '+%H:%M:%S') (Bras√≠lia)%0A%0Aüîç Problemas:%0A$PROBLEMS%0Aüî• VERIFICAR URGENTE!"
            
            # Enviar alerta imediato
            curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d "text=$MESSAGE" || echo "‚ö†Ô∏è Falha ao enviar alerta"
            
            echo "üö® ALERTA ENVIADO para ${{ matrix.site.name }}!"
            exit 1  # Falha o job para aparecer no GitHub
          else
            echo "‚úÖ ${{ matrix.site.name }} funcionando normalmente"
          fi

  # üöÄ MONITORAMENTO DE TR√ÅFEGO VERCEL - Detecta Picos de Acesso
  monitor-vercel-traffic:
    runs-on: ubuntu-latest
    
    steps:
      - name: üîç Detectar TODOS os Projetos Vercel Automaticamente
        id: traffic-check
        run: |
          echo "üöÄ Detectando TODOS os projetos Vercel automaticamente..."
          
          # Configura√ß√µes da Vercel (adicione esses secrets no GitHub)
          VERCEL_TOKEN="${{ secrets.VERCEL_TOKEN }}"
          VERCEL_TEAM_ID="${{ secrets.VERCEL_TEAM_ID }}"
          
          if [[ -z "$VERCEL_TOKEN" ]]; then
            echo "‚ö†Ô∏è VERCEL_TOKEN n√£o configurado - usando lista est√°tica"
            # Fallback para lista est√°tica se n√£o tiver token
            PROJECTS=(
              "rasparei|https://rasparei.com/|10"
              "admin-raspaganha|https://admin.raspaganha.sa.com/|15"
              "raspaganha-v2|https://raspaganha-v2.vercel.app/|10"
            )
          else
            echo "üîë Usando API da Vercel para detectar projetos automaticamente..."
            
            # Buscar todos os projetos da equipe
            if [[ -n "$VERCEL_TEAM_ID" ]]; then
              PROJECTS_JSON=$(curl -s -H "Authorization: Bearer $VERCEL_TOKEN" \
                "https://api.vercel.com/v1/teams/$VERCEL_TEAM_ID/projects" || echo "[]")
            else
              PROJECTS_JSON=$(curl -s -H "Authorization: Bearer $VERCEL_TOKEN" \
                "https://api.vercel.com/v1/projects" || echo "[]")
            fi
            
            # Extrair dom√≠nios de todos os projetos
            PROJECTS=()
            echo "$PROJECTS_JSON" | jq -r '.projects[]? | select(.domains != null) | .domains[]? | select(.verified == true) | .name' 2>/dev/null | while read -r domain; do
              if [[ -n "$domain" ]]; then
                # Adicionar timeout baseado no tipo de dom√≠nio
                if [[ "$domain" == *"admin"* ]] || [[ "$domain" == *"dashboard"* ]]; then
                  timeout="15"
                elif [[ "$domain" == *"canary"* ]] || [[ "$domain" == *"staging"* ]] || [[ "$domain" == *"dev"* ]]; then
                  timeout="8"
                else
                  timeout="10"
                fi
                
                PROJECTS+=("$domain|https://$domain/|$timeout")
                echo "üåê Detectado: $domain (timeout: ${timeout}s)"
              fi
            done
            
            # Se n√£o conseguiu detectar via API, usar fallback
            if [[ ${#PROJECTS[@]} -eq 0 ]]; then
              echo "‚ö†Ô∏è Falha na API - usando lista est√°tica"
              PROJECTS=(
                "rasparei|https://rasparei.com/|10"
                "admin-raspaganha|https://admin.raspaganha.sa.com/|15"
                "raspaganha-v2|https://raspaganha-v2.vercel.app/|10"
              )
            fi
          fi
          
          # Contadores para an√°lise
          HIGH_TRAFFIC_COUNT=0
          PROBLEM_PROJECTS=""
          TOTAL_PROJECTS=${#PROJECTS[@]}
          
          echo "üìä Total de projetos detectados: $TOTAL_PROJECTS"
          
          # Verificar cada projeto
          for project in "${PROJECTS[@]}"; do
            IFS='|' read -r project_name url timeout <<< "$project"
            
            echo "üåê Verificando $project_name..."
            
            # Health check + an√°lise de tr√°fego
            RESPONSE=$(curl -s -w "HTTPSTATUS:%{http_code};TIME:%{time_total};SIZE:%{size_download}" \
                           --max-time $timeout \
                           "$url" || echo "HTTPSTATUS:000;TIME:999;SIZE:0")
            
            STATUS=$(echo $RESPONSE | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
            TIME=$(echo $RESPONSE | grep -o "TIME:[0-9.]*" | cut -d: -f2)
            SIZE=$(echo $RESPONSE | grep -o "SIZE:[0-9]*" | cut -d: -f2)
            
            # Detectar problemas de tr√°fego
            TRAFFIC_ISSUE=""
            if [[ "$STATUS" == "000" ]]; then
              TRAFFIC_ISSUE="üö® OFFLINE - Poss√≠vel sobrecarga"
              HIGH_TRAFFIC_COUNT=$((HIGH_TRAFFIC_COUNT + 1))
            elif [[ "$STATUS" != "200" ]]; then
              TRAFFIC_ISSUE="‚ö†Ô∏è ERRO $STATUS - Poss√≠vel sobrecarga"
              HIGH_TRAFFIC_COUNT=$((HIGH_TRAFFIC_COUNT + 1))
            elif (( $(echo "$TIME > 5.0" | bc -l 2>/dev/null || echo "0") )); then
              TRAFFIC_ISSUE="üî• ALTO TR√ÅFEGO - ${TIME}s"
              HIGH_TRAFFIC_COUNT=$((HIGH_TRAFFIC_COUNT + 1))
            elif (( $(echo "$TIME > 3.0" | bc -l 2>/dev/null || echo "0") )); then
              TRAFFIC_ISSUE="‚ö†Ô∏è TR√ÅFEGO ELEVADO - ${TIME}s"
            fi
            
            if [[ -n "$TRAFFIC_ISSUE" ]]; then
              PROBLEM_PROJECTS="${PROBLEM_PROJECTS}‚Ä¢ $project_name: $TRAFFIC_ISSUE%0A"
            fi
            
            echo "   üìä Status: $STATUS | ‚ö° Tempo: ${TIME}s | üìÑ Tamanho: $SIZE bytes | $TRAFFIC_ISSUE"
          done
          
          # Salvar resultados para uso posterior
          echo "high_traffic_count=$HIGH_TRAFFIC_COUNT" >> $GITHUB_OUTPUT
          echo "problem_projects=$PROBLEM_PROJECTS" >> $GITHUB_OUTPUT
          echo "total_projects=$TOTAL_PROJECTS" >> $GITHUB_OUTPUT
          
          echo "üìä Resumo: $HIGH_TRAFFIC_COUNT/$TOTAL_PROJECTS com problemas de tr√°fego"
      
      - name: üÜï Detectar Novos Dom√≠nios e Notificar
        if: steps.traffic-check.outputs.total_projects > 0
        run: |
          echo "üÜï Verificando se h√° novos dom√≠nios..."
          
          # Comparar com lista anterior (se existir)
          CURRENT_DOMAINS=$(echo "${{ steps.traffic-check.outputs.problem_projects }}" | grep -o '[^|]*' | head -1)
          
          # Salvar lista atual para pr√≥xima compara√ß√£o
          echo "$CURRENT_DOMAINS" > /tmp/current_domains.txt
          
          # Se for primeira execu√ß√£o, n√£o notificar
          if [[ ! -f /tmp/previous_domains.txt ]]; then
            echo "üìù Primeira execu√ß√£o - salvando lista de dom√≠nios"
            cp /tmp/current_domains.txt /tmp/previous_domains.txt
            exit 0
          fi
          
          # Comparar dom√≠nios atuais com anteriores
          NEW_DOMAINS=$(comm -13 /tmp/previous_domains.txt /tmp/current_domains.txt | grep -v '^$')
          
          if [[ -n "$NEW_DOMAINS" ]]; then
            echo "üÜï Novos dom√≠nios detectados:"
            echo "$NEW_DOMAINS"
            
            # Notificar sobre novos dom√≠nios
            MESSAGE="üÜï NOVOS DOM√çNIOS DETECTADOS!%0A%0Aüåê Novos projetos:%0A"
            
            while IFS= read -r domain; do
              if [[ -n "$domain" ]]; then
                MESSAGE="${MESSAGE}‚Ä¢ $domain%0A"
              fi
            done <<< "$NEW_DOMAINS"
            
            MESSAGE="${MESSAGE}%0AüìÖ Data: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y')%0A‚è∞ Hora: $(TZ='America/Sao_Paulo' date '+%H:%M:%S') (Bras√≠lia)%0A%0A‚úÖ Monitoramento autom√°tico ativado!"
            
            # Enviar notifica√ß√£o
            curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
              -d "text=$MESSAGE" || echo "‚ö†Ô∏è Falha ao notificar novos dom√≠nios"
            
            echo "üÜï Notifica√ß√£o de novos dom√≠nios enviada!"
          else
            echo "‚úÖ Nenhum novo dom√≠nio detectado"
          fi
          
          # Atualizar lista anterior
          cp /tmp/current_domains.txt /tmp/previous_domains.txt
      
      - name: üö® Alerta de Alto Tr√°fego Simult√¢neo
        if: steps.traffic-check.outputs.high_traffic_count >= 1
        run: |
          echo "üö® ALERTA: Projeto com problema de tr√°fego detectado!"
          
          MESSAGE="üö® ALERTA DE TR√ÅFEGO VERCEL%0A%0Aüî• ${{ steps.traffic-check.outputs.high_traffic_count }}/${{ steps.traffic-check.outputs.total_projects }} projetos com problemas%0A%0Aüìä DOM√çNIOS AFETADOS:%0A${{ steps.traffic-check.outputs.problem_projects }}%0AüìÖ Data: $(TZ='America/Sao_Paulo' date '+%d/%m/%Y')%0A‚è∞ Hora: $(TZ='America/Sao_Paulo' date '+%H:%M:%S') (Bras√≠lia)%0A%0Aüö® VERIFICAR DOM√çNIO AFETADO URGENTE!"
          
          # Enviar alerta cr√≠tico para Telegram
          curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
            -d "chat_id=${{ secrets.TELEGRAM_CHAT_ID }}" \
            -d "text=$MESSAGE" || echo "‚ö†Ô∏è Falha ao enviar alerta"
          
          echo "üö® Alerta de alto tr√°fego enviado!"
      
      - name: üìä Relat√≥rio de Tr√°fego
        if: always()
        run: |
          echo "üìä Relat√≥rio de Tr√°fego Vercel"
          echo "‚è∞ Verifica√ß√£o: $(date '+%Y-%m-%d %H:%M:%S')"
          echo "üéØ Total de projetos: ${{ steps.traffic-check.outputs.total_projects }}"
          echo "üö® Projetos com problemas: ${{ steps.traffic-check.outputs.high_traffic_count }}"
          
          if [[ "${{ steps.traffic-check.outputs.high_traffic_count }}" -ge 1 ]]; then
            echo "üö® ALERTA ATIVO: ${{ steps.traffic-check.outputs.high_traffic_count }} projeto(s) com problemas!"
            echo "üìä Dom√≠nios afetados:"
            echo "${{ steps.traffic-check.outputs.problem_projects }}"
          else
            echo "‚úÖ Tr√°fego normal em todos os projetos"
          fi

  # üìä RESUMO GERAL (executa sempre, mesmo se sites falharem)
  summary:
    runs-on: ubuntu-latest
    needs: [monitor-sites, monitor-vercel-traffic]
    if: always()
    
    steps:
      - name: üìä Resumo do Monitoramento
        run: |
          echo "üìä Monitoramento 24/7 + Tr√°fego Vercel executado"
          echo "‚è∞ Hor√°rio: $(date '+%Y-%m-%d %H:%M:%S')"
          
          # Em caso de falhas, o GitHub Actions j√° mostra no dashboard
          # Aqui voc√™ pode adicionar l√≥gica para contar sucessos/falhas
          
          echo "‚úÖ Pr√≥xima verifica√ß√£o em 5 minutos"
          echo "üöÄ Monitoramento de tr√°fego Vercel ativo"
